@page "/starlanesgame"

<div class="row">
    <h1>Star Lanes</h1>
</div>
@*
    <p>Current size: @(X_dimension)x@(Y_dimension) </p>
    <p>Current UBounds: @(Map.GetUpperBound(0))x@(Map.GetUpperBound(1)) </p>
*@

@if (GameConfig.GameState == GameConfiguration.GameStates.NotStarted)
{
    <p>
        <label for="numberOfPlayers"># of Players:</label> <input id="numberOfPlayers" type="number" min="2" max="@GameConfiguration.Max_NumberOfPlayers" @bind="GameConfig.NumberOfPlayers" />
    </p>
    <p>
        @for (int p = 1; p <= GameConfig.NumberOfPlayers; p++)
        {

            var pa = p - 1;
            @*<span class="text-danger">@_playerNameValidationMessage(p))</span>*@
            <label for="playerName(@p)">Player @p Name:</label> <input id="playerName(@p)" type="text" minlength="2" maxlength="20" @bind="PlayerName[pa]" />
            <label for="computerPlayer(@p)" style="font-size: small;"><input type="checkbox" id="computerPlayer(@p)" @bind="ComputerPlayer[pa]" /> Computer Player</label>
            <br />
        }
    </p>

    <div class="form-check-inline"><label><input type="radio" class="form-check-input" name="gameformat" value="standard" checked @onchange="(e) => GameConfig.SetMapSize(12,9)">Standard Game (12x9)</label></div>
    <div class="form-check-inline"><label><input type="radio" class="form-check-input" name="gameformat" value="large" @onchange="(e) => GameConfig.SetMapSize(16,12)">Big Game (16x12)</label></div>
    <div class="form-check-inline"><label><input type="radio" class="form-check-input" name="gameformat" value="jumbo" @onchange="(e) => GameConfig.SetMapSize(20,16)">Jumbo Game (20x16)</label></div>

    <p>
        <button class="btn btn-primary" @onclick="InitializeGame">Start Game!</button>
    </p>

    @*
        <div id="AdvOptionsAccordion">
            <div class="card">
                <div class="card-header" id="AdvOptionsHeader">
                    <h5 class="mb-0">
                        <button class="btn btn-link" data-toggle="collapse" data-target="#AdvOptions" aria-expanded="true" aria-controls="AdvOptions">
    *@

    <p>
        <button @onclick="(e) => ToggleAdvancedOptions()" class="btn btn-outline-secondary" data-toggle="buttons">
            @(AdvancedOptionsVisible ? "Hide" : "Show") Advanced Options
        </button>
    </p>

    @if (AdvancedOptionsVisible)
    {
        <div id="AdvOptions" class="collapse show" visible>

            @*   <div id="AdvOptions" class="collapse show" aria-labelledby="AdvOptionsHeader" data-parent="#AdvOptionsAccordion"> *@

            <label for="NumberOfCompanies">Max # of Companies: </label><input id="NumberOfCompanies" type="number" min="5" max="@GameConfiguration.Max_NumberOfCompanies" @bind="GameConfig.NumberOfCompanies" /> (5-10, default 5)<br />
            <label for="MapSize">Map Size: </label><input id="MapSizeX" type="number" min="6" max="20" @bind="GameConfig.X_dimension" /> x <input id="MapSizeY" type="number" min="5" max="20" @bind="GameConfig.Y_dimension" /> (Min 6x5, Normal 12x9, Max 20x20, default 12x9)<br />
            <label for="StarLikelihood">Star Likelihood: </label><input id="StarLikelihood" type="number" min="0" max="15" @bind="GameConfig.StarChance" />% (0-15, default 10)<br />
            <label for="BlackholeLikelihood">Black Hole Likelihood: </label><input id="BlackholeLikelihood" type="number" min="0" max="5" @bind="GameConfig.BlackholeChance" />% (0-5, default 3)<br />
            <label for="BlackholeConsumptionChance">Black Hole Consumption %: </label><input id="BlackholeConsumptionChance" type="number" min="0" max="100" @bind="GameConfig.BlackholeConsumptionChance" /> (0-100, default 25, applies to developed sectors, not companies)<br />
            @*<label for="StartingOrder">Starting Player:</label><br />*@
            <input type="checkbox" name="RandomizeWhoGoesFirst" @bind="GameConfig.RandomizeFirstMover" /><label for="RandomizeWhoGoesFirst">Randomize Who Goes First</label> <br />
            <label for="FounderShares">Founder Shares: </label><input type="number" id="NumFounderShares" min="0" max="20" @bind="GameConfig.FounderShares" /> (0-20, default 5)<br />
            <label for="StartingMoney">Starting Money: </label><input type="number" id="AmountStartingMoney" min="1000" max="10000" step="100" @bind="GameConfig.PlayerStartingMoney" /> (1,000-20,000, default 6,000)<br />
            <label for="DividendsPercentage">Dividends %: </label><input id="DividendsPercentage" type="number" min="1" max="10" @bind="GameConfig.DividendPercentage" />% (1-10, default 5)<br />
            <label for="MergerRatio">Merger Ratio: </label><input id="MergerRatio" type="number" min="1" max="5" @bind="GameConfig.MergerRatio" /> (1-5, default 2, number of shares of smaller merged company to equal 1 in new company)<br />
            <input type="checkbox" name="StockSplits" @bind="GameConfig.StockSplits" /><label for="StockSplitPrice">Stock Split at: $</label><input id="StockSplitPrice" disabled="@(!GameConfig.StockSplits)" type="number" min="2000" max="20000" step="100" @bind="GameConfig.StockSplitPrice" /><br/>
            <label for="SectorValue">Sector Value $: </label><input id="SectorValue" type="number" min="0" max="500" step="100" @bind="GameConfig.NormalValue" /> (0-500, 100 default) <br />
            <label for="StarSectorValue">Star Sector Value $: </label><input id="StarSectorValue" type="number" min="0" max="2000" step="100" @bind="GameConfig.StarValue" /> (0-2000, 500 default) <br />
            <label for="BlackholeDestructive">Blackhole Destroys: </label><input id="BlackholeDestroys" type="checkbox" @bind="GameConfig.BlackholeDestroys" /> (If false, Blackhole adjacency only penalizes stock value)<br />
            <label for="BlackholeSectorValue">Blackhole Sector Value $: </label><input id="BlackholeSectorValue" disabled="@(GameConfig.BlackholeDestroys)" type="number" min="-2000" max="0" step="100" @bind="GameConfig.BlackholeValue" /> (-2000-0, -500 default) <br />
            <label for="NumberOfRounds"># of Rounds: </label><input checked id="defaultRoundsByPlayerCount" type="checkbox" @onchange="(e) => { SetDefaultRounds(e); }" /> Use Default <input disabled="@(GameConfig.DefaultRounds)" id="NumberOfRounds" type="number" min="1" max="24" @bind="GameConfig.NumberOfRounds" /> (1-24, default based on number of players with 48-50 total turns)<br />
            <label for="AvailableMovesPerTurn"># of Available Moves: </label><input id="AvailableMovesPerTurn" type="number" min="4" max="5" @bind="GameConfig.NumberOfMoves" /> (3-5, default 4)<br />

        </div>
    }

}

@if ((GameConfig.GameState != GameConfiguration.GameStates.NotStarted) && (GameConfig.GameState != GameConfiguration.GameStates.GameEnding))
{

    @* Game Status Header *@
    <div class="row">
        <div class="col-3 header-round">
            Round @(GameRound) of @(GameConfig.NumberOfRounds)
        </div>
        @* Show whose turn it is *@
        <div class="col-9 turn-instructions-panel">
            <p>
                <label style="font-weight:bold">@(Players.ContainsKey(PlayerTurn) != true ? "" : Players[PlayerTurn].Name + "'s") Turn: </label>
                <label>
                    @((MarkupString)(GameConfig.GameState == GameConfiguration.GameStates.PlayerMove ? "<b>Move<b> >" : "Move > "))
                    @((MarkupString)(GameConfig.GameState == GameConfiguration.GameStates.PlayerStockPurchasing ? "<b>Stock Buying<b> > " : "Stock Trading > "))
                    End Turn 
                </label>
            </p>
        </div>
    </div>

    @* Show player status *@
    <div class="container row justify-content-center player-status-panel">
        <div>
            @foreach (var p in Players)
            {

                <div class="container player-status-box @(PlayerTurn == p.Key ? "player-status-box-active" : "")">
                    <div class="player-status-box-name @(PlayerTurn == p.Key ? "player-status-name-active" : "")">
                        @(p.Value.Name + " ["+ PlayerRank(p.Key) + "]") @((MarkupString)PlayerIcon(p.Key))
                    </div>
                    <div class="player-status-box-money">
                        Bank: @("$" + p.Value.Money.ToString())
                    </div>
                    <div class="player-status-box-stocks">
                        @foreach (var c in Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value))
                        {
                            @((MarkupString)(c.Value.Symbol + ":&nbsp;" + c.Value.StockHolderShares[p.Key].ToString() + "&nbsp;&nbsp; "))
                        }
                    </div>
                    <div class="player-status-box-networth">
                        @(("Net Worth: $" + PlayerNetWorth(p.Key)))
                    </div>
                </div>
            }
        </div>
    </div>

    <div class="container row event-panel clearfix" style="width: 100%; height: 100px; margin: 25px 0px;">
        <div class="col-2 event-panel-title">
            Universal Newswire
        </div>
        <div class="col-10 event-panel-readout overflow-auto">
            @((MarkupString)EventsText())
        </div>
    </div>

    <div class="container-fluid clearfix">
        <div class="row" style="height:400px">
            @* Container for side-by-side map and newswire*@

            @* Map Display *@
            <div class="map-panel">
                <div class="map" style="float:left;">
                    <div class="map-title">Map of the Universe</div>
                    <div class="map-title">@((String.Concat(Enumerable.Repeat("*", GameConfig.X_dimension * 3 - 2))))</div>
                    <div class="map-sectors">
                        <div class="map-x-axis" style="clear: both;">
                            <div class="map-sector">&nbsp;</div>
                            @for (int x = 0; x <= map.X_Dimension; x++)
                            {
                                <div class="map-sector map-axis map-x-axis">@((char)(x + 65))</div>
                            }
                        </div>

                        @for (int y = 0; y <= map.Y_Dimension; y++)
                        {
                            <div style="clear: both;">
                                <div class="map-sector map-axis map-y-axis" style="float: left; clear: none">@(y + 1)</div>
                                @for (int x = 0; x <= map.X_Dimension; x++)
                                {
                                    <div class="map-sector @(SectorClass(map[x, y])) @((GameStateObj.LastMove != null) && (GameStateObj.LastMove.X == x) && (GameStateObj.LastMove.Y == y) ? "map-last-move" : "")">@(map[x, y])</div>
                                }
                            </div>
                        }
                    </div>

                </div>

            </div>

            <div class="player-actions">
                <fieldset id="playeractionelements" disabled="@(!(Players[PlayerTurn].IsHuman))">
                    @* Available Move Buttons *@
                    <div class="player-moves-panel">
                        @if (GameConfig.GameState == GameConfiguration.GameStates.PlayerMove)
                        {
                            <div class="player-moves-title">Available Moves:</div>
                            @foreach (var move in AvailableMoves)
                            {
                                <button class="btn btn-outline-secondary move-button" hidden="@(GameConfig.GameState != GameConfiguration.GameStates.PlayerMove)" disabled="@(GameConfig.GameState != GameConfiguration.GameStates.PlayerMove)" @onclick="(e => { MakeMove(move.Key); })">@(move.Value)</button>
                            }
                            <div>
                                @* if this is testing, allow for the player to regenerate the available moves *@
                                @if (GameStateObj.TestGame)
                                {
                                    <button class="btn btn-primary" @onclick="(e => { map.RemoveMovesFromMap(AvailableMoves); AvailableMoves = GenerateMoves(); map.AddMovesToMap(AvailableMoves); })">GenerateMoves</button>
                                }
                            </div>
                        }
                    </div>

                    @* Stock purchasing buttons*@


                    @if (GameConfig.GameState == GameConfiguration.GameStates.PlayerStockPurchasing)
                    {
                        @* if there are any companies *@
                        @if (Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value).Count > 0)
                        {
                            <div class="clearfix">
                                <span class="bold-small-header">Buy Stocks with $@(Players[PlayerTurn].Money) ($@(AvailableMoneyForStockBuying()) unallocated)</span>
                            </div>
                            <div class="clearfix">
                                @foreach (var c in Companies)
                                {
                                    @if (c.Value.IsActive)
                                    {
                                        <div class="row stock-to-buy-box">
                                            <div class="w-auto">
                                                <label>@(c.Value.Name)&nbsp;</label>
                                            </div>
                                            <div class="w-auto">
                                                <label for="Buy=@(c.Key)">$@(c.Value.ShareValue) x </label>
                                                <input id="Buy=@(c.Key)" style="width:3em" type="number" @bind="GameStateObj.StockToBuy[c.Key]" min="0" max="@(MaxCanBuy(c.Key))" />
                                                <button class="btn btn-secondary btn-xs" @onclick="() => { GameStateObj.StockToBuy[c.Key] = MaxCanBuy(c.Key); }">Max</button>
                                            </div>
                                        </div>
                                        @*                     <button class="btn btn-secondary btn-xs" onclick="alert(" onclick="document.getElementById("Buy=@(c.Key)").value = document.getElementById("Buy=@(c.Key)").attr('max');";">Max</button> *@

                                        @*
                                            <label class="player-actions-buysellstock">@(c.Value.Name)</label>
                                            <button class="btn btn-outline-secondary btn-xs" disabled="@(GameState != GameStates.PlayerStockPurchasing)" @onclick="(e => { BuyStock(PlayerTurn, c.Key, 1); })"> + </button>
                                            <span class="btn btn-outline-secondary btn-sm">@(c.Value.StockHolderShares[PlayerTurn])</span>
                                            <button class="btn btn-outline-secondary btn-xs" disabled="@(GameState != GameStates.PlayerStockPurchasing)" @onclick="(e => { SellStock(PlayerTurn, c.Key, 1); })"> - </button>
                                        *@
                                    }
                                }
                            </div>

                        }
                        else @* no companies *@
                        {
                            <div>
                                No companies available for stock purchasing
                            </div>
                        }

                        @* End Turn Button for Humans Players on their turns *@
                        @if (Players[PlayerTurn].IsHuman)
                        {
                            <div style="text-align: center; margin: 10px 0px; align-self:flex-end">
                                <button class="btn btn-primary" disabled="@(GameConfig.GameState != GameConfiguration.GameStates.PlayerStockPurchasing)" @onclick="(e => { EndTurn(); })">@(Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value).Count > 0 ? "Buy Stocks & Complete Turn" : "Complete Turn")</button>
                            </div>
                        }
                    }
                </fieldset>

                @* End Turn Button for Human to continue game after Computer Turn *@
                @if ((GameConfig.GameState == GameConfiguration.GameStates.PlayerStockPurchasing) && (Players[PlayerTurn].IsComputer))
                {
                    <div style="text-align: center; margin: 10px 0px; align-self:flex-end">
                        <button class="btn btn-primary" @onclick="(e => { EndTurn(); })"> Next Turn </button>
                    </div>
                }
            </div>
        </div>
    </div>

    @* Map Display *@
    @*
        <div class="map-panel">
            <div class="map">
                <label>@((MarkupString)(String.Concat(Enumerable.Repeat("&nbsp", Convert.ToInt32(Math.Floor((double)(2 + X_dimension * 3 - 1 - MapTitle.Length) / 2.0))))))@MapTitle</label><br />
                <label>@((MarkupString)("&nbsp&nbsp" + (String.Concat(Enumerable.Repeat("*", X_dimension * 3 - 2)))))</label><br />
                <label>@((MarkupString)PrintMap())</label>
            </div>
        </div>
    *@
    @*
        <div class="clearfix">
    *@

    @* Show event readout *@
    @*
            <div class="event-panel" style="float:left margin: 0px 50px 0px 0px;">
                <div class="event-panel-title">
                    Universal Newswire
                </div>
                <div class="event-panel-readout">
                    @((MarkupString)EventsText())
                </div>
            </div>
        </div>
    *@
    @* Show company status *@
    <div class="company-status-panel">

        @* Leftmost box is column names *@
        <div class="company-status-key">
            <div class="company-status-box-name">
                Company:
            </div>
            <div class="company-status-box-sharevalue">
                Share Value($):
            </div>
            <div class="company-status-box-sharesoutstanding">
                Outstanding Shares:
            </div>
            <div class="player-status-box-size">
                # of Sectors:
            </div>
        </div>

        @foreach (var c in Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value))
        {
            <div class="company-status-box">
                <div class="company-status-box-name">
                    @(c.Value.Name)
                </div>
                <div class="company-status-box-sharevalue">
                    @(c.Value.ShareValue.ToString())
                </div>
                <div class="company-status-box-sharesoutstanding">
                    @(c.Value.OutstandingShares())
                </div>
                <div class="company-status-box-size">
                    @(CompanySize(c.Value))
                </div>
            </div>
        }

    </div>
}

@if (GameConfig.GameState == GameConfiguration.GameStates.GameEnding)
{
    <h2>The Game is over!</h2>

    <p>After @((GameConfig.NumberOfRounds <= GameRound) ? GameConfig.NumberOfRounds : GameRound) Round@((GameConfig.NumberOfRounds > 1) ? "s" : "")...</p>
    <h3>@(Players[GameStateObj.Winner].Name) is the winner!</h3>
    <table class="table">
        <tr>
            <th>Rank</th>
            <th>Player</th>
            <th>Stock</th>
            <th>Cash</th>
            <th>Net Worth</th>
        </tr>
        @foreach (var p in Players.OrderBy(r => r.Value.FinalRank))
        {
            <tr class="@( (PlayerRank(p.Key) == 1) ? "table-primary" : "" )" style="@((PlayerRank(p.Key) == 1) ? "font-weight: 700" : "")">
                <th>@(PlayerRank(p.Key))</th>
                <td>@(p.Value.Name) @(p.Value.Name + " ["+ PlayerRank(p.Key) + "]") @((MarkupString)PlayerIcon(p.Key))</td>
                <td>$@(PlayerStockWorth(p.Key))</td>
                <td>$@(Players[p.Key].Money)</td>
                <td>$@(PlayerNetWorth(p.Key))</td>
            </tr>
        }
    </table>

}


@code {

    //UI only functions
    private string GenerateControlRef(int Id)
    {
        return "Move" + Id.ToString();
    }

    private string PlayerIcon(int Id)
    {
        if (Players[Id].IsComputer)
            return "<img src=" + (char)34 + "css/font-awesome/robot.svg" + (char)34 + " width=" + (char)34 + "16" + (char)34 + " height=" + (char)34 + "16" + (char)34 + " alt=" + (char)34 + "C" + (char)34 + " />";
        else
            return "";
    }

    public bool AdvancedOptionsVisible = false;
    private void ToggleAdvancedOptions()
    {
        AdvancedOptionsVisible = !AdvancedOptionsVisible;
    }





    // Initialize Randomizer
    Random rand = new Random();

    //Initialize Map object
    public Map map = new Map(1, 1);

    // Initialize Companies
    Dictionary<int, Company>
    Companies = new Dictionary<int, Company>
        ();

    //Initialize Player dictionary
    string[] PlayerName = new string[GameConfiguration.Max_NumberOfPlayers];
    bool[] ComputerPlayer = new bool[GameConfiguration.Max_NumberOfPlayers];
    Dictionary<int, Player>
        Players = new Dictionary<int, Player>
            ();

    //Create Stock Holding Tracker
    public int[,] StockHoldings = new int[1, 1];    //Redim this later
    public Dictionary<string, int>
        Stocks = new Dictionary<string, int>
            ();

    // Game state variables
    int PlayerTurn = 1;
    public int GameRound = 0;
    Dictionary<int, Move>
        AvailableMoves = new Dictionary<int, Move>
            ();
    string MovesDescription = string.Empty;

    // Events objects for relaying game eent updates to players
    public class Event
    {
        public readonly int Turn;
        public readonly string Message;

        public Event(int turn, string message)
        {
            Turn = turn;
            Message = message;
        }
    }

    public Queue<Event>
        Events = new Queue<Event>
            ();

    public class GameStateObject
    {
        public int NumberOfPlayers = 2;
        public int[] StockToBuy = new int[GameConfiguration.Max_NumberOfCompanies + 1];
        public int MoneyToBuy = 0;
        public bool TestGame = false;
        public int Winner = 0;
        public Move LastMove { get; set; }

        public GameStateObject()
        {

        }

        public void ResetStockExchange()
        {
            Array.Clear(StockToBuy, 0, StockToBuy.Length);
        }


    }

    public GameStateObject GameStateObj = new GameStateObject();

    public GameConfiguration GameConfig = new GameConfiguration();

    #region Test Games
    private void LoadTestGamePlayerNames()
    {
        //Test Game Player Setuo
        PlayerName[0] = "Chris";
        PlayerName[1] = "Geoff";
        if (GameConfig.NumberOfPlayers > 2)
            PlayerName[2] = "Holly";
        if (GameConfig.NumberOfPlayers > 3)
            PlayerName[3] = "Muffin";
        if (GameConfig.NumberOfPlayers > 4)
            PlayerName[4] = "Whoever";
    }

    private void TestGame1()
    {
        GameStateObj.TestGame = true;

        map[2, 1] = "A";
        map[3, 1] = "A";
        map[4, 1] = "A";

        map[1, 3] = "B";
        map[2, 3] = "B";
        map[3, 3] = "B";
        map[4, 3] = "B";

        map[6, 1] = "C";
        map[6, 2] = "C";
        map[5, 2] = "C";
        map[7, 1] = Map.StarSector;

        map[3, 5] = Map.BlackholeSector;

        Companies[1].OpenCompany(1, GameConfig.FounderShares);
        CalculateSharePrice(Companies[1]);

        Companies[2].OpenCompany(2, GameConfig.FounderShares);
        CalculateSharePrice(Companies[2]);

        Companies[3].OpenCompany(3, GameConfig.FounderShares);
        CalculateSharePrice(Companies[3]);

        StateHasChanged();

    }

    private void TestGame2()
    {
        TestGame1();
    }
    #endregion Test Games

    #region Set Rounds
    private void SetDefaultRounds(ChangeEventArgs e)
    {
        GameConfig.DefaultRounds = Convert.ToBoolean(e.Value);
        if (GameConfig.DefaultRounds)
            UpdateRoundsBasedOnPlayerCount();

    }

    //private void UpdateRoundsBasedOnPlayerCount(ChangeEventArgs e)
    private void UpdateRoundsBasedOnPlayerCount()
    {
        //    if(e.Value.GetType() == typeof(int)) {
        //        NumberOfPlayers = Int32.Parse(e.Value.ToString());
        //    }

        switch (GameConfig.NumberOfPlayers)
        {
            case 2:
                GameConfig.NumberOfRounds = 24; break;
            case 3:
                GameConfig.NumberOfRounds = 18; break;
            case 4:
                GameConfig.NumberOfRounds = 12; break;
            case 5:
                GameConfig.NumberOfRounds = 10; break;
            default:
                GameConfig.NumberOfRounds = 12; break;
        }
    }
    #endregion Set Rounds

    private void InitializeGame()
    {
        GameConfig.GameState = GameConfiguration.GameStates.Initiating;

        //ReDim Map
        //My = new string[X_dimension, Y_dimension];
        map = new Map(GameConfig.X_dimension, GameConfig.Y_dimension);

        //Load Test Names
        //    LoadTestGamePlayerNames();

        // Randomize who starts game first
        if (GameConfig.RandomizeFirstMover)
            GameConfig.FirstPlayer = rand.Next(0, GameConfig.NumberOfPlayers - 1);
        else
            GameConfig.FirstPlayer = 0;

        GameRound = 1;
        if (GameConfig.DefaultRounds)
            UpdateRoundsBasedOnPlayerCount();

        //    if (NumberOfPlayers == 5)
        //        NumberOfMoves = 50; // 48 is the usual count, but not divisible by 5

        //Mild deviation from the original - reset player numbers to put who ever goes first as player 1

        // Initialize Players
        GameStateObj.NumberOfPlayers = GameConfig.NumberOfPlayers;

        int nameIndex = GameConfig.FirstPlayer;
        for (int l = 1; l <= GameStateObj.NumberOfPlayers; l++)
        {
            // Start each Player with some $ and set their name
            Players.Add(l, new Player(PlayerName[nameIndex], GameConfig.PlayerStartingMoney, ComputerPlayer[nameIndex] ? Player.RandomComputerPersona() : Player.Personas.Human));
            if (string.IsNullOrWhiteSpace(Players[l].Name))
            { Players[l].SetDefaultName(l); }  // Assign default name if none was entered
            nameIndex = (nameIndex < (GameStateObj.NumberOfPlayers - 1) ? nameIndex + 1 : 0);
        }

        // Initialize Companies
        for (int companyIndex = 1; companyIndex <= GameConfig.Max_Companies; companyIndex++)
        {
            Companies.Add(companyIndex, new Company(companyIndex, GameStateObj.NumberOfPlayers));
        }

        //Initialize Map with empty sectors
        for (int y = 0; y <= map.Y_Dimension; y++)
        {
            for (int x = 0; x <= map.X_Dimension; x++)
            {
                int sectortype = rand.Next(1, 100);

                if ((GameConfig.StarChance > 0) && (GameConfig.BlackholeChance > 0))
                {
                    if (sectortype <= GameConfig.StarChance)
                        map[x, y] = Map.StarSector;
                    else if (sectortype <= (GameConfig.StarChance + GameConfig.BlackholeChance))
                        map[x, y] = Map.BlackholeSector;
                    else
                        map[x, y] = Map.EmptySector;
                }
                else if (GameConfig.StarChance > 0)
                {
                    if (sectortype <= GameConfig.StarChance)
                        map[x, y] = Map.StarSector;
                    else
                        map[x, y] = Map.EmptySector;
                }
                else
                    map[x, y] = Map.EmptySector;

            }
        }

        // Initialize Stock Holdings
        StockHoldings = new int[GameConfig.Max_Companies, GameConfig.NumberOfPlayers];

        //    TestGame1();

        LogGameEvent("The Game has begun!");

        // Start the first Turn
        ExecuteTurn();

    }


    async Task Sleep(int Duration)
    {
        await Task.Delay(Duration);
    }

    private void ExecuteTurn()
    {
        GameStateObj.LastMove = null;
        GameConfig.GameState = GameConfiguration.GameStates.PlayerMove;

        //Generate the moves for the next player
        AvailableMoves = GenerateMoves();
        map.AddMovesToMap(AvailableMoves);

        if (Players[PlayerTurn].IsComputer)
        {
            ExecuteComputerTurn();
        }
    }

    async void ExecuteComputerTurn()
    {
        // Computer move

        await Sleep(1000);

        //Have computer user make move selection
        int computerMove = SelectComputerMove(AvailableMoves, PlayerTurn);
        MakeMove(computerMove);

        await Sleep(1000);

        //ExecuteMove(AvailableMoves[computerMove].X, AvailableMoves[computerMove].Y, map);
        GameConfig.GameState = GameConfiguration.GameStates.PlayerStockPurchasing;

        // Have computer user make stock purchases
        int computerStockToBuy = BuyComputerStock(PlayerTurn);
        if (computerStockToBuy > 0)
        {
            // MaxCanBuy
            int sharesToBuy = MaxCanBuy(computerStockToBuy);
            GameStateObj.StockToBuy[computerStockToBuy] = sharesToBuy;
            // Post visible event, transaction will finalize on "Next Turn" button press by player
            if (sharesToBuy > 0)
                LogGameEvent(Players[PlayerTurn].Name + " is purchasing " + sharesToBuy.ToString() + " shares of " + Companies[computerStockToBuy].Name);

            //GameStateObj.ResetStockExchange();
        }
    }

    private int SelectComputerMove(Dictionary<int, Move>
        moves, int playerId)
    {
        switch (Players[playerId].Persona)
        {
            case Player.Personas.ERNIE:
                return rand.Next(1, AvailableMoves.Count); ;   //random move;
            default:
                return rand.Next(1, AvailableMoves.Count); ;   //random move;
        }
    }

    private int BuyComputerStock(int playerId)
    {
        if (ExistingCompanies() == 0) { return 0; } // No Companies to buy stock in

        //Check holdings and buy more of the same company as initial logic
        int mostOwned = 0;
        int ownedShares = 0;
        int cheapestStock = 0;

        for (int i = 1; i <= Companies.Count; i++)
        {
            if (Companies[i].IsActive)
            {
                if (Companies[i].StockHolderShares[playerId] >= ownedShares)
                {
                    mostOwned = i;
                }
            }
        }

        // Doesn't own any stock right now, buy cheapest
        if (mostOwned == 0)
        {

            int stockValue = 999999999;

            for (int i = 1; i <= Companies.Count; i++)
            {
                if (Companies[i].IsActive)
                {
                    if (Companies[i].ShareValue < stockValue)
                    {
                        cheapestStock = i;
                    }
                }
            }
        }

        return (mostOwned != 0 ? mostOwned : cheapestStock);
    }


    public long AvailableMoneyForStockBuying()
    {
        return AvailableMoneyForStockBuying(0); // pass a 0 to indicate not to exclude any company;
    }

    public long AvailableMoneyForStockBuying(int ExcludeCompanyId)
    {
        long availableMoney = Players[PlayerTurn].Money;
        //    Console.WriteLine("StockToBuy.Length=" + GameStateObj.StockToBuy.Length + " ExcludeId = " + ExcludeCompanyId.ToString());
        //    foreach (int i in GameStateObj.StockToBuy)
        for (int i = GameStateObj.StockToBuy.GetLowerBound(0); i <= GameStateObj.StockToBuy.GetUpperBound(0); i++)
        {
            if (i != ExcludeCompanyId && Companies.ContainsKey(i) && Companies[i].IsActive)
            {
                //           Console.Write(Companies[i].Symbol + "=" + GameStateObj.StockToBuy[i]);
                availableMoney -= GameStateObj.StockToBuy[i] * Companies[i].ShareValue;
                //           Console.Write("(" + availableMoney.ToString() + ")");
            }
        }

        Console.WriteLine();
        return availableMoney;
    }

    public int MaxCanBuy(int CompanyKey)
    {
        return Convert.ToInt32(Math.Floor(AvailableMoneyForStockBuying(CompanyKey) / (double)Companies[CompanyKey].ShareValue));
    }

    public void ExecuteStockTrades()
    {
        for (int i = 0; i <= GameStateObj.StockToBuy.Length; i++)
        {
            if (Companies.ContainsKey(i) && Companies[i].IsActive && (GameStateObj.StockToBuy[i] > 0))
            {
                BuyStock(PlayerTurn, i, GameStateObj.StockToBuy[i]);
            }
        }
    }

    private int BuyStock(int playerId, int companyId, int shares)
    {
        //int shares = 1;

        //Determine if the player has enough money
        if (Players[playerId].Money >= (shares * Companies[companyId].ShareValue))
        {
            //Buy shares
            Players[playerId].Money -= (shares * Companies[companyId].ShareValue);  // Take away the money
            Companies[companyId].StockHolderShares[playerId] += shares; // Add the shares
        }
        else
            shares = 0; // no shares bought

        return shares;
    }

    [Obsolete("Selling not exercised in this version", true)]
    private int SellStock(int playerId, int companyId, int shares)
    {
        // Determine if player has that many shares to sell, if trying to sell more than have, sell all
        if (Companies[companyId].StockHolderShares[playerId] < shares)
            shares = Companies[companyId].StockHolderShares[playerId];

        // Sell the stock
        Players[playerId].Money += (shares * Companies[companyId].ShareValue); // Give the money
        Companies[companyId].StockHolderShares[playerId] -= shares;

        return shares;
    }

    private void GetMoves()
    {
        AvailableMoves = GenerateMoves();
    }

    private int ExistingCompanies()
    {
        return Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value).Count;
    }

    private Dictionary<int, Move> GenerateMoves()
    {
        //        int x_move;
        //        int y_move;
        //MoveOutcome move_outcome;

        SortedDictionary<string, Move>
            tempMoves = new SortedDictionary<string, Move>
                ();

        int existingCompanies = ExistingCompanies();

        List<Move>
            openSectors = map.OpenSectors();
        int moveIndex;

        // Find open moves
        for (int l = 1; ((l <= GameConfig.NumberOfMoves) && (l <= openSectors.Count)); l++)
        {
            bool moveisgood;
            // Find an open move
            do
            {
                moveIndex = rand.Next(0, openSectors.Count - 1);
                moveisgood = true; // since we pull from a list of pre-validated open sectors, start with assumption of true

                // prevent creation of too many companies
                if (existingCompanies == GameConfig.Max_Companies)
                {
                    // check if move will create new company
                    if (DetermineMoveOutcome(openSectors[moveIndex].X, openSectors[moveIndex].Y) == MoveOutcome.StartNewCompany)
                        moveisgood = false;
                }

            } while (!moveisgood);

            // Add move to the list of available moves and remove from the pool for next move selection
            Move nm = new Move(openSectors[moveIndex].X, openSectors[moveIndex].Y);
            tempMoves.Add(nm.ToString(), nm);
            openSectors.RemoveAt(moveIndex);
        }

        //Take the sorted dictionary and re-key to numeric index
        Dictionary<int, Move>
            moves = new Dictionary<int, Move>
                ();
        foreach (Move mv in tempMoves.Values)
            moves.Add(moves.Count + 1, mv);

        // Ensure Map Display -- ADD CODE to move this to a controller most likely
        GameConfig.GameState = GameConfiguration.GameStates.PlayerMove;
        StateHasChanged();

        //return moves;
        return moves;
    }

    public void MakeMove(int moveNumber)
    {
        Move move = AvailableMoves[moveNumber];

        //Update Status
        //GameStatus = "Player " + PlayerTurn.ToString() + " opens up sector " + move.ToString();
        LogGameEvent(Players[PlayerTurn].Name + " develops sector " + move.ToString());
        // Update map with new status based on move
        map.RemoveMovesFromMap(AvailableMoves);
        map[move.X, move.Y] = Map.DevelopedSector;

        GameConfig.GameState = GameConfiguration.GameStates.PlayerStockPurchasing;

        // Calculate results of the move
        GameStateObj.LastMove = move;
        ExecuteMove(move.X, move.Y, map);


        //Advance Game
        GameConfig.GameState = GameConfiguration.GameStates.PlayerStockPurchasing;

    }


    private void EndTurn()
    {
        //Buy Stocks
        //if (Players[PlayerTurn].IsHuman) { ExecuteStockTrades(); } //already executed if non-human player turn
        ExecuteStockTrades();
        GameStateObj.ResetStockExchange();
        StateHasChanged();

        // Increment Turn
        bool newRound = NextPlayerTurn();

        if (GameRound > GameConfig.NumberOfRounds)
        {
            // The Game is over!
            GameConfig.GameState = GameConfiguration.GameStates.GameEnding;

            // Determine the final rankings
            foreach (var p in Players)
            {
                p.Value.FinalRank = PlayerRank(p.Key);
                if (p.Value.FinalRank == 1)
                    GameStateObj.Winner = p.Key;
            }
        }
        else //start the next round
        {
            // Pay Dividends to start the round
            if (newRound) PayDividends();


            ExecuteTurn();

        }
    }

    private void PayDividends()
    {
        foreach (var p in Players)
        {
            p.Value.Money += (int)Math.Round(PlayerStockWorth(p.Key) * (double)GameConfig.DividendPercentage / 100);
        }
    }

    @* Returns True if new round *@
private bool NextPlayerTurn()
{
    PlayerTurn++;
    if (PlayerTurn > GameConfig.NumberOfPlayers)
    {
        PlayerTurn = 1;
        GameRound++;
        return true;
    }
    else { return false; }
}

private string SectorClass(string sectorValue)
{
    switch (sectorValue)
    {
        case Map.NullSector:
            return "map-sector-null";
        case Map.EmptySector:
            return "map-sector-empty";
        case Map.DevelopedSector:
            return "map-sector-developed";
        case Map.StarSector:
            return "map-sector-star";
        case Map.BlackholeSector:
            return "map-sector-blackhole";
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
            return "map-sector-move";
    }

    if ("ABCDEFGHIJKL".Contains(sectorValue)) return "map-sector-company";

    return String.Empty;
}

//prints the map using text string - for debugging purposes only
public string PrintMap()
{
    return map.PrintMap(GameConfig.GameState == GameConfiguration.GameStates.PlayerMove, AvailableMoves);
}

public int CalculateAdjacentSectorValue(string sectorstate)
{
    switch (sectorstate)
    {
        case Map.StarSector:
            return GameConfig.StarValue;
        case Map.BlackholeSector:
            return (GameConfig.BlackholeDestroys ? 0 : GameConfig.BlackholeValue);
        default:
            return 0;
    }
}

public int CalculateSharePrice(Company company)
{
    int value = 0;

    for (int x = 0; x <= map.X_Dimension; x++)
    {
        for (int y = 0; y <= map.Y_Dimension; y++)
        {
            if (map[x, y] == company.Symbol)    //if the company owns this sector
            {
                value += 100; // for the sector itself
                string[] neighbors = map.GetNeighbors(x, y);
                foreach (string s in neighbors)
                { value += CalculateAdjacentSectorValue(s); }
            }
        }
    }

    return value - company.SplitOffset;
}


public int CompanySize(Company company)
{
    return map.NumberOfSymbolsOnMap(company.Symbol);
}

public long PlayerStockWorth(int playerid)
{
    int stockvalue = 0;
    foreach (Company c in Companies.Values)
    {
        stockvalue += c.StockHolderShares[playerid] * c.ShareValue;
    }
    return stockvalue;
}

public long PlayerNetWorth(int playerid)
{
    return Players[playerid].Money + PlayerStockWorth(playerid);
}

public MoveOutcome DetermineMoveOutcome(int x, int y)
{
    {
        // evalute nearby spaces to determine outcome of this move
        MoveOutcome moveOutcome = MoveOutcome.DevelopSector;

        //initialize adjacent locals
        string[] neighbors = map.GetNeighbors(x, y);
        List<string>
            adjacentCompanies = map.AdjacentCompanies(x, y);


        // Check for adjacent companies
        if (adjacentCompanies.Count == 0)
        {
            // If it's all empty sectors nearby
            if (String.Join("", neighbors) == new String('x', 4).Replace("x", Map.EmptySector))
            {
                moveOutcome = MoveOutcome.DevelopSector;
            }

            // Check for creation of new company
            if ((String.Join("", neighbors).Contains(Map.StarSector)) || (String.Join("", neighbors).Contains(Map.DevelopedSector)))
            {
                moveOutcome = MoveOutcome.StartNewCompany;
            }
        }
        // Check for expansion of company
        else if (adjacentCompanies.Count == 1)
        {
            moveOutcome = MoveOutcome.ExpandCompany;
        }
        // Check for Merger
        else if (adjacentCompanies.Count > 1)
        {
            moveOutcome = MoveOutcome.Merger;
        }

        //Check for black hole
        if (moveOutcome != MoveOutcome.StartNewCompany) // there will be two outcomes actually, but the new company will cause issues if max companies already exist, so prevent that
        {
            if (GameConfig.BlackholeChance > 0)
            {
                if (String.Join("", neighbors).Contains(Map.BlackholeSector))
                {
                    moveOutcome = MoveOutcome.Blackhole;
                }
            }
        }

        return moveOutcome;
    }
}

public MoveOutcome ExecuteMove(int x, int y, Map theMap)
{
    // evalute nearby spaces to determine outcome of this move
    MoveOutcome moveOutcome = MoveOutcome.DevelopSector; //default

    //initialize adjacent locals
    string[] neighbors = theMap.GetNeighbors(x, y);
    List<string>
        adjacentCompanies = theMap.AdjacentCompanies(x, y);

    // Develop Sector
    theMap[x, y] = Map.DevelopedSector;

    // Check for adjacent companies
    if (adjacentCompanies.Count == 0)
    {
        // If it's all empty sectors nearby
        if (String.Join("", neighbors) == new String('x', 4).Replace("x", Map.EmptySector))
        {
            // Develop Sector
            theMap[x, y] = Map.DevelopedSector;
        }

        // Check for creation of new company
        if ((String.Join("", neighbors).Contains(Map.StarSector)) || (String.Join("", neighbors).Contains(Map.DevelopedSector)))
        {
            // Make a new company
            moveOutcome = MoveOutcome.StartNewCompany;
            int newCo = AvailableCompanySlot();

            if (newCo == 0)
            { } // ?? Shouldn't end up here, no more companies available! ADD CODE to handle this?

            // Open up the new company
            Companies[newCo].OpenCompany(PlayerTurn, GameConfig.FounderShares);
            theMap[x, y] = Companies[newCo].Symbol;

            // Expand into any adjacent developed sectors
            if (neighbors[0] == Map.DevelopedSector)
                theMap[x, y - 1] = Companies[newCo].Symbol;
            if (neighbors[1] == Map.DevelopedSector)
                theMap[x - 1, y] = Companies[newCo].Symbol;
            if (neighbors[2] == Map.DevelopedSector)
                theMap[x + 1, y] = Companies[newCo].Symbol;
            if (neighbors[3] == Map.DevelopedSector)
                theMap[x, y + 1] = Companies[newCo].Symbol;

            LogGameEvent("NEW COMPANY!", Players[PlayerTurn].Name + " has founded a new company, " + Companies[newCo].Name + ".");
        }
    }
    // Check for expansion of company
    else if (adjacentCompanies.Count == 1)
    {
        //Expansion
        moveOutcome = MoveOutcome.ExpandCompany;

        // Expand into "move" sector
        theMap[x, y] = adjacentCompanies[0];

        // Expand into any developed adjacent sectors
        if (neighbors[0] == Map.DevelopedSector)
            theMap[x, y - 1] = adjacentCompanies[0];
        if (neighbors[1] == Map.DevelopedSector)
            theMap[x - 1, y] = adjacentCompanies[0];
        if (neighbors[2] == Map.DevelopedSector)
            theMap[x + 1, y] = adjacentCompanies[0];
        if (neighbors[3] == Map.DevelopedSector)
            theMap[x, y + 1] = adjacentCompanies[0];
    }
    // Check for Merger
    else if (adjacentCompanies.Count > 1)
    {
        //Merger!
        moveOutcome = MoveOutcome.Merger;

        //Sort companies by alpabetical
        adjacentCompanies.Sort();

        string foo = String.Empty;

        // Add the symbol and the size to a dictionary to iterate
        Dictionary<string, int>
            coS = new Dictionary<string, int>
                ();
        foreach (string s in adjacentCompanies)
        {
            coS.Add(s, CompanySize(Companies[Company.KeyFromSymbol(s)]));
            foo += s + "=" + coS[s] + ", ";
        }

        string survivor = string.Empty;

        // Merge largest and smallest companies, until we're down to just one company
        do
        {
            int winner = 0;
            for (int i = 1; i < coS.Count; i++)
            {
                if (coS.ElementAt(i).Value > coS.ElementAt(winner).Value)
                    winner = i;
            }

            survivor = coS.ElementAt(winner).Key;

            int loser = coS.Count - 1;
            for (int i = coS.Count - 2; i >= 0; i--)
            {
                if (coS.ElementAt(i).Value < coS.ElementAt(loser).Value)
                    loser = i;
            }

            // merge winner and loser
            MergeCompanies(Companies[Company.KeyFromSymbol(coS.ElementAt(winner).Key)], Companies[Company.KeyFromSymbol(coS.ElementAt(loser).Key)]);

            string winnerName = Companies[Company.KeyFromSymbol(coS.ElementAt(winner).Key)].Name;
            string loserName = Companies[Company.KeyFromSymbol(coS.ElementAt(loser).Key)].Name;
            LogGameEvent("MERGER!!!!!", $"{winnerName} and {loserName} have merged! The unified company will now be known as {winnerName}.");

            //remove loser
            coS.Remove(coS.ElementAt(loser).Key);
        } while (coS.Count > 1);

        // Update the newly developed sector that created the merger
        theMap[x, y] = survivor;

        //StateHasChanged();
    }

    //Check for black hole(s), that could wipe out any newly merged or expanded companies!
    if (GameConfig.BlackholeChance > 0)
    {
        for (int x_loop = 0; x_loop <= theMap.X_Dimension; x_loop++)
        {
            for (int y_loop = 0; y_loop <= theMap.Y_Dimension; y_loop++)
            {
                if (theMap[x_loop, y_loop] == Map.BlackholeSector)
                {
                    //Wipe out companies that touched the blackhole!
                    adjacentCompanies = theMap.AdjacentCompanies(x_loop, y_loop);
                    if (adjacentCompanies.Count > 0)
                    {
                        foreach (string c in adjacentCompanies)
                        {
                            theMap.ReplaceSymbolOnMap(Companies[Company.KeyFromSymbol(c)].Symbol, Map.EmptySector);
                            Companies[Company.KeyFromSymbol(c)].CloseCompany();

                            LogGameEvent("DISASTER!", Companies[Company.KeyFromSymbol(c)].Name + " sucked into black hole at Sector " + Move.ToString(x_loop, y_loop));
                        }
                    }

                    //Randomly destroy developed sectors next to blackholes
                    string[] blackholeNeighbors = theMap.GetNeighbors(x_loop, y_loop);
                    for (int n = 0; n < blackholeNeighbors.GetUpperBound(0); n++)
                    {
                        if (blackholeNeighbors[n] == Map.DevelopedSector)
                        {
                            if (rand.Next(1, 100) <= GameConfig.BlackholeConsumptionChance)
                            {
                                // Destroy the sector
                                int x_destroyed = x_loop;
                                int y_destroyed = y_loop;
                                if (n == 0) { y_destroyed = y_loop - 1; }
                                if (n == 1) { x_destroyed = x_loop - 1; }
                                if (n == 2) { x_destroyed = x_loop + 1; }
                                if (n == 3) { y_destroyed = y_loop + 1; }


                                // The sector just developed on this turn cannot be destroyed on the same turn
                                if ((x != x_destroyed) && (y != y_destroyed))
                                {
                                    theMap[x_destroyed, y_destroyed] = Map.NullSector;
                                    LogGameEvent("Sector " + Move.ToString(x_destroyed, y_destroyed) + " consumed by black hole!");
                                }
                            }
                        }
                    }
                }
            }
        }

    }

    // Calculate the final share prices
    foreach (Company company in Companies.Values)
    {
        if (company.IsActive)
        {
            company.ShareValue = CalculateSharePrice(company);

            // Check for bankruptcy
            if (company.ShareValue <= 0)    // for games that use blackholes as negative values on stock price
            {
                company.CloseCompany();
                LogGameEvent("BANKRUPCTY!", company.Name + " has gone bankrupt and is out of business.");
            }

            // Check for stock split
            if (GameConfig.StockSplits)
            {
                while (company.ShareValue >= GameConfig.StockSplitPrice)
                {
                    company.SplitStock(GameConfig.StockSplitPrice);
                    LogGameEvent("Stock Split!", company.Name + " has split 2-for-1.");
                }
            }
        }
    }


    //Force redraw of maps
    StateHasChanged();

    return moveOutcome;
}

public void MergeCompanies(Company winner, Company loser)
{
    //Update Map
    map.ReplaceSymbolOnMap(loser.Symbol, winner.Symbol);

    // Trade in old stock
    foreach (var item in loser.StockHolderShares)
    {
        winner.StockHolderShares[item.Key] += (item.Value / GameConfig.MergerRatio); // Award at 2 old for 1 new
        Players[item.Key].Money += ((item.Value % GameConfig.MergerRatio) * loser.ShareValue); // Pay out remainer share
    }

    // Close down prior company
    loser.CloseCompany();
}

public int AvailableCompanySlot()
{
    foreach (var item in Companies)
    {
        if (!item.Value.IsActive) return item.Key;
    }

    return 0;   // no available company slots
}

private string EventsText()
{
    //List events in reverse chronological order
    string eventString = String.Empty;
    for (int i = Events.Count - 1; i >= 0; i--)
    {
        bool currentTurn = ((GameRound - 1) * GameConfig.NumberOfPlayers + PlayerTurn == Events.ElementAt(i).Turn);
        Console.WriteLine(((GameRound - 1) * GameConfig.NumberOfPlayers + PlayerTurn).ToString(), Events.ElementAt(i).Turn);
        eventString += (currentTurn ? "<b>" : "") + Events.ElementAt(i).Message + (currentTurn ? "</b>" : "") + "<br />";
    }
    return eventString;
    //return String.Join("<br />", Events.ToArray().Reverse());
}

private void LogGameEvent(string eventText)
{
    LogGameEvent("", eventText);
}

private void LogGameEvent(string eventHeader, string eventText)
{
    if (Events.Count >= 10)
        Events.Dequeue();
    Events.Enqueue(new Event((GameRound - 1) * GameConfig.NumberOfPlayers + PlayerTurn, "Round " + GameRound.ToString() + "&raquo; " + eventHeader + " " + eventText));
}



private int PlayerRankOld(int playerId)
{
    int rank = 1;
    long netWorth = PlayerNetWorth(playerId);
    for (int i = 1; i <= Players.Count; i++)
    {
        if (i != playerId)
        {
            long iNetWorth = PlayerNetWorth(i);
            if (iNetWorth > netWorth)       // Tie breaker one: Net Worth
                rank++;
            else if (iNetWorth == netWorth)
                if (PlayerStockWorth(i) > PlayerStockWorth(playerId)) // Tie breaker two: Stock value
                    rank++;
                else if (playerId < i)  // Tie breaker three: player who had later move is considered disadvantaged, so gets ranked higher
                    rank++;
        }
    }

    return rank;
}

private int PlayerRank(int PlayerId)
{
    /*
    int[] rankings = PlayerRanks();
    for (int i = 0; i <= rankings.GetUpperBound(0); i++)
    {
    if (rankings[i] == PlayerId)
    return i+1;
    }
    return 0; //oops
    */

    Dictionary<int, int>
        rankings = PlayerRanks();

    return rankings[PlayerId];
}

private Dictionary<int, int>
    PlayerRanks()
{

    Dictionary<int, long>
        rankvalues = new Dictionary<int, long>
            ();

    foreach (var p in Players)
    {
        // rubric for sorting
        rankvalues.Add(p.Key, PlayerNetWorth(p.Key) * (long)10000000 + PlayerStockWorth(p.Key) * 10 + p.Key);
        Console.WriteLine("Ranking value player " + p.Key + " = " + rankvalues[p.Key]);
    }

    var results = rankvalues.OrderByDescending(p => p.Value);

    Dictionary<int, int>
        ranking = new Dictionary<int, int>
            ();

    foreach (KeyValuePair<int, long>
        pair in results)
    {
        ranking.Add(pair.Key, ranking.Count + 1);
        Console.WriteLine("Ranking value player " + pair.Key + " = " + ranking[pair.Key]);
    }

    return ranking;
}
}

