@page "/starlanesgame"

<div class="row">
    <h1>Star Lanes</h1>
</div>
@*
    <p>Current size: @(X_dimension)x@(Y_dimension) </p>
    <p>Current UBounds: @(Map.GetUpperBound(0))x@(Map.GetUpperBound(1)) </p>
*@

@if (GameState == GameStates.NotStarted)
{
<p>
    <label for="numberOfPlayers"># of Players:</label> <input id="numberOfPlayers" type="number" min="2" max="@Max_NumberOfPlayers" @bind="NumberOfPlayers" />
</p>
<p>
    @for (int p = 1; p <= NumberOfPlayers; p++)
        {

            var pa = p - 1;
    <label for="playerName(@p)">Player @p Name:</label>  <input id="playerName(@p)" type="text" minlength="2" maxlength="20" @bind="PlayerName[pa]" />
    <br />
        }
</p>

<p>
    <button class="btn btn-primary" @onclick="InitializeGame">Start Game!</button>
</p>

<h3>Advanced Options</h3>
<p>
    <label for="NumberOfCompanies">Max # of Companies: </label><input id="NumberOfCompanies" type="number" min="5" max="@Max_NumberOfCompanies" @bind="Max_Companies" /> (5-10, default 5)<br />
    <label for="MapSize">Map Size: </label><input id="MapSizeX" type="number" min="12" max="20" @bind="X_dimension" /> x <input id="MapSizeY" type="number" min="9" max="20" @bind="Y_dimension" /> (Min 12x9, Max 20x20, default 12x9)<br />
    <label for="StarLikelihood">Star Likelihood: </label><input id="StarLikelihood" type="number" min="0" max="15" @bind="StarChance" />% (0-15, default 10)<br />
    <label for="BlackholeLikelihood">Black Hole Likelihood: </label><input id="BlackholeLikelihood" type="number" min="0" max="5" @bind="BlackholeChance" />% (0-10, default 3)<br />
    <label for="StartingOrder">Starting Player:</label><br /><input type="radio" id="InOrder" name="StartingOrder" value="1" /><label for="InOrder">In Order Above</label><br />
    <input type="radio" id="RandomStart" name="StartingOrder" value="2" checked /><label for="RandomStart">Random Starter</label><br />
    <input type="radio" id="All Random" name="StartingOrder" value="3" /><label for="InOrder">Random Starter, Random Order</label><br />
    <label for="FounderShares">Founder Shares: </label><input type="number" id="NumFounderShares" min="0" max="20" @bind="FounderShares" /> (0-20, default 5)<br />
    <label for="StartingMoney">Starting Money: </label><input type="number" id="AmountStartingMoney" min="1000" max="10000" @bind="PlayerStartingMoney" /> (1,000-20,000, default 6,000)<br />
    <label for="DividendsPercentage">Dividends %: </label><input id="DividendsPercentage" type="number" min="1" max="10" @bind="DividendPercentage" />% (1-10, default 5)<br />
    <label for="NumberOfRounds"># of Rounds: </label><input checked id="defaultRoundsByPlayerCount" type="checkbox" @onchange="(e) => { SetDefaultRounds(e); }" /> Use Default <input disabled="@(DefaultRounds)" id="NumberOfRounds" type="number" min="1" max="24" @bind="NumberOfRounds" /> (1-15, default based on number of players)<br />
    <label for="AvailableMovesPerTurn"># of Available Moves: </label><input id="AvailableMovesPerTurn" type="number" min="4" max="5" @bind="NumberOfAvailableMoves" /> (3-5, default 4)<br />
</p>
}

@if ((GameState != GameStates.NotStarted) && (GameState != GameStates.GameEnding))
{

@* Game Status Header *@
<div class="row">
    <div class="col-3 header-round">
        Round @(GameRound) of @(NumberOfRounds)
    </div>
    @* Show whose turn it is *@
    <div class="col-9 turn-instructions-panel">
        <p>
            <label style="font-weight:bold">@(Players.ContainsKey(PlayerTurn) != true ? "" : Players[PlayerTurn].Name + "'s") Turn: </label>
            <label>
                @((MarkupString)(GameState == GameStates.PlayerMove ? "<b>Move<b> >" : "Move > "))
                @((MarkupString)(GameState == GameStates.PlayerStockPurchasing ? "<b>Stock Buying<b> > " : "Stock Trading > "))
                End Turn
            </label>
        </p>
    </div>
</div>

@* Show player status *@
<div class="container row justify-content-center player-status-panel">
    <div>
        @foreach (var p in Players)
            {

        <div class="container player-status-box @(PlayerTurn == p.Key ? "player-status-box-active" : "")">
            <div class="player-status-box-name @(PlayerTurn == p.Key ? "player-status-name-active" : "")">
                @(p.Value.Name + " ["+ PlayerRank(p.Key) + "]")
            </div>
            <div class="player-status-box-money">
                Bank: @("$" + p.Value.Money.ToString())
            </div>
            <div class="player-status-box-stocks">
                @foreach (var c in Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value))
                        {
                @((MarkupString)(c.Value.Symbol + ":&nbsp;" + c.Value.StockHolderShares[p.Key].ToString() + "&nbsp;&nbsp; "))
                        }
            </div>
            <div class="player-status-box-networth">
                @(("Net Worth: $" + PlayerNetWorth(p.Key)))
            </div>
        </div>
            }
    </div>
</div>

<div class="container row event-panel clearfix" style="width: 100%; height: 100px; margin: 25px 0px;">
    <div class="col-2 event-panel-title">
        Universal Newswire
    </div>
    <div class="col-10 event-panel-readout overflow-auto">
        @((MarkupString)EventsText())
    </div>
</div>

<div class="container-fluid clearfix">
    <div class="row" style="height:400px">
        @* Container for side-by-side map and newswire*@

        @* Map Display *@
        <div class="map-panel">
            <div class="map" style="float:left;">
                <div class="map-title">Map of the Universe</div>
                <div class="map-title">@((String.Concat(Enumerable.Repeat("*", X_dimension * 3 - 2))))</div>
                <div class="map-sectors">
                    <div class="map-x-axis" style="clear: both;">
                        <div class="map-sector">&nbsp;</div>
                        @for (int x = 0; x <= map.X_Dimension; x++)
                            {
                        <div class="map-sector map-axis map-x-axis">@((char)(x + 65))</div>
                            }
                    </div>

                    @for (int y = 0; y <= map.Y_Dimension; y++)
                        {
                    <div style="clear: both;">
                        <div class="map-sector map-axis map-y-axis" style="float: left; clear: none">@(y + 1)</div>
                        @for (int x = 0; x <= map.X_Dimension; x++)
                                {
                        <div class="map-sector @(SectorClass(map[x, y]))">@(map[x, y])</div>
                                }
                    </div>
                        }
                </div>

            </div>

        </div>

        <div class="player-actions">
            @* Stock purchasing buttons*@

            @if (GameState == GameStates.PlayerStockPurchasing)
                {
            @* if there are any companies *@
            @if (Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value).Count > 0)
                    {
            <div class="clearfix">
                <span class="bold-small-header">Buy Stocks with $@(Players[PlayerTurn].Money) ($@(AvailableMoneyForStockBuying()) unallocated)</span>
            </div>
            <div class="clearfix">
                @foreach (var c in Companies)
                    {
                @if (c.Value.IsActive)
                                {
                <div class="row stock-to-buy-box">
                    <div class="w-auto">
                        <label>@(c.Value.Name)&nbsp;</label>
                    </div>
                    <div class="w-auto">
                        <label for="Buy=@(c.Key)">$@(c.Value.ShareValue) x </label>
                        <input id="Buy=@(c.Key)" style="width:3em" type="number" @bind="GameStateObj.StockToBuy[c.Key]" min="0" max="@(MaxCanBuy(c.Key))" />
                        <button class="btn btn-secondary btn-xs" @onclick="() => { GameStateObj.StockToBuy[c.Key] = MaxCanBuy(c.Key); }">Max</button>
                    </div>
                </div>
                @*                     <button class="btn btn-secondary btn-xs" onclick="alert(" onclick="document.getElementById("Buy=@(c.Key)").value = document.getElementById("Buy=@(c.Key)").attr('max');";">Max</button> *@

                @*
                    <label class="player-actions-buysellstock">@(c.Value.Name)</label>
                    <button class="btn btn-outline-secondary btn-xs" disabled="@(GameState != GameStates.PlayerStockPurchasing)" @onclick="(e => { BuyStock(PlayerTurn, c.Key, 1); })"> + </button>
                    <span class="btn btn-outline-secondary btn-sm">@(c.Value.StockHolderShares[PlayerTurn])</span>
                    <button class="btn btn-outline-secondary btn-xs" disabled="@(GameState != GameStates.PlayerStockPurchasing)" @onclick="(e => { SellStock(PlayerTurn, c.Key, 1); })"> - </button>
                *@
                                }
                            }
            </div>

                    }
                    else @* no companies *@
                    {
                    <div>
                        No companies available for stock purchasing
                    </div>
                    }
            @* End Turn Button *@
            <div style="text-align: center; margin: 10px 0px; align-self:flex-end">
                <button class="btn btn-secondary" disabled="@(GameState != GameStates.PlayerStockPurchasing)" @onclick="(e => { EndTurn(); })">@(Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value).Count > 0 ? "Buy Stocks & Complete Turn" : "End Turn")</button>
            </div>

                }

            @* Available Move Buttons *@
            <div class="player-moves-panel">
                @if (GameState == GameStates.PlayerMove)
                    {
                <div class="player-moves-title">Available Moves:</div>
                @foreach (var move in AvailableMoves)
                        {
                <button class="btn btn-outline-secondary move-button" hidden="@(GameState != GameStates.PlayerMove)" disabled="@(GameState != GameStates.PlayerMove)" @onclick="(e => { MakeMove(move.Key); })">@(move.Value)</button>
                        }
                <div>
                    @* if this is testing, allow for the player to regenerate the available moves *@
                    @if (GameStateObj.TestGame)
                            {
                    <button class="btn btn-primary" @onclick="(e => { RemoveMovesFromMap(); AvailableMoves = GenerateMoves(); AddMovesToMap(); })">GenerateMoves</button>
                            }
                </div>
                    }
            </div>
        </div>
    </div>
</div>

@* Map Display *@
@*
    <div class="map-panel">
        <div class="map">
            <label>@((MarkupString)(String.Concat(Enumerable.Repeat("&nbsp", Convert.ToInt32(Math.Floor((double)(2 + X_dimension * 3 - 1 - MapTitle.Length) / 2.0))))))@MapTitle</label><br />
            <label>@((MarkupString)("&nbsp&nbsp" + (String.Concat(Enumerable.Repeat("*", X_dimension * 3 - 2)))))</label><br />
            <label>@((MarkupString)PrintMap())</label>
        </div>
    </div>
*@
@*
    <div class="clearfix">
*@

@* Show event readout *@
@*
        <div class="event-panel" style="float:left margin: 0px 50px 0px 0px;">
            <div class="event-panel-title">
                Universal Newswire
            </div>
            <div class="event-panel-readout">
                @((MarkupString)EventsText())
            </div>
        </div>
    </div>
*@
@* Show company status *@
<div class="company-status-panel">

    @* Leftmost box is column names *@
    <div class="container company-status-key">
        <div class="company-status-box-name">
            Company:
        </div>
        <div class="company-status-box-sharevalue">
            Share Value($):
        </div>
        <div class="company-status-box-sharesoutstanding">
            Outstanding Shares:
        </div>
        <div class="player-status-box-size">
            # of Sectors:
        </div>
    </div>

    @foreach (var c in Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value))
        {
    <div class="container company-status-box">
        <div class="company-status-box-name">
            @(c.Value.Name)
        </div>
        <div class="company-status-box-sharevalue">
            @(c.Value.ShareValue.ToString())
        </div>
        <div class="company-status-box-sharesoutstanding">
            @(c.Value.OutstandingShares())
        </div>
        <div class="company-status-box-size">
            @(CompanySize(c.Value))
        </div>
    </div>
        }

</div>
}

@if (GameState == GameStates.GameEnding)
{
<h2>The Game is over!</h2>

@foreach (var p in Players)
    {
<label>@PlayerRank(p.Key)) @(p.Value.Name): $</label><label>@(PlayerNetWorth(p.Key))</label>
    }

}


@code {


    public int[,] StockHoldings = new int[1, 1];    //Redim this later
    public Dictionary<string, int> Stocks = new Dictionary<string, int>();


    // Initialzie Randomizer
    Random rand = new Random();

    // Initialize Companies
    public const int Max_NumberOfCompanies = 10;
    public int Max_Companies = 5;   //configurable
    public int FounderShares = 5;
    Dictionary<int, Company> Companies = new Dictionary<int, Company>();

    //Initialize Map
    const int Max_X_dimension = 20;
    const int Max_Y_dimension = 15;
    public int X_dimension = 12;
    public int Y_dimension = 9;
    public int StarChance = 10;
    public int BlackholeChance = 3;
    public int BlackholeConsumptionChance = 25; // chance a developed sector will be consumed by a black hole

    @*public string[,] My = new string[1, 1]; *@
public Map map = new Map(1, 1);

//Initialize Sector Values
const int NormalValue = 100;
const int StarValue = 500;

//Finance Constants
public int MergerRatio = 2; // Old shares needed to equal one new share
public int PlayerStartingMoney = 6000;
public int DividendPercentage = 5;

//Initialize Player dictionary
const int Max_NumberOfPlayers = 5;
public int NumberOfPlayers = 4;
string[] PlayerName = new string[Max_NumberOfPlayers];
Dictionary<int, Player> Players = new Dictionary<int, Player>();


// Game state variables
int PlayerTurn = 1;
//Dictionary<int, string> OldMoves = new Dictionary<int, string>();
Dictionary<int, Move> AvailableMoves = new Dictionary<int, Move>();
string MovesDescription = string.Empty;
string GameStatus = "Not Started.";
public enum GameStates
{
    NotStarted = 0,
    Initiating = 1,
    PlayerMove = 10,
    PlayerStockPurchasing = 15,
    BetweenMoves = 15,
    GameEnding = 20,
    GameEnded = 25
}
public GameStates GameState = GameStates.NotStarted;
public int GameRound = 0;
public int FirstPlayer = 0;
public int MaxNumberOfMovesPerGame = 48;
public int NumberOfRounds = 12;
public bool DefaultRounds = true;
public int NumberOfMoves = 4;
public int NumberOfAvailableMoves = 4;  // # of sectors the player is allowed to choose among to develop on his turn

public Queue<string> Events = new Queue<string>();

public class GameStateObject
{
    public int NumberOfPlayers = 2;
    public int[] StockToBuy = new int[Max_NumberOfCompanies + 1];
    public int MoneyToBuy = 0;
    public bool TestGame = false;

    public GameStateObject()
    {

    }

    public void ResetStockExchange()
    {
        Array.Clear(StockToBuy, 0, StockToBuy.Length);
    }




}

public GameStateObject GameStateObj = new GameStateObject();

private void LoadTestGamePlayerNames()
{
    //Test Game Player Setuo
    PlayerName[0] = "Chris";
    PlayerName[1] = "Geoff";
    if (NumberOfPlayers > 2)
        PlayerName[2] = "Holly";
    if (NumberOfPlayers > 3)
        PlayerName[3] = "Muffin";
    if (NumberOfPlayers > 4)
        PlayerName[4] = "Whoever";
}

private void TestGame1()
{
    GameStateObj.TestGame = true;

    map[2, 1] = "A";
    map[3, 1] = "A";
    map[4, 1] = "A";

    map[1, 3] = "B";
    map[2, 3] = "B";
    map[3, 3] = "B";
    map[4, 3] = "B";

    map[6, 1] = "C";
    map[6, 2] = "C";
    map[5, 2] = "C";
    map[7, 1] = Map.StarSector;

    map[3, 5] = Map.BlackholeSector;

    Companies[1].OpenCompany(1, FounderShares);
    CalculateSharePrice(Companies[1]);

    Companies[2].OpenCompany(2, FounderShares);
    CalculateSharePrice(Companies[2]);

    Companies[3].OpenCompany(3, FounderShares);
    CalculateSharePrice(Companies[3]);

    StateHasChanged();

}

private void TestGame2()
{
    TestGame1();
}

//Convert a string to map values - used for loading maps for things such as testing;
private void StringToMapSection(string MapString, int StartX = 0, int Y = 0)
{
    for (int x = 0; x < MapString.Length; x++)
    {
        if ((x + StartX) < map.X_Dimension)
            map[x, Y] = MapString[x + StartX].ToString();
    }
}

//Convert an array of strings to map values - used for loading maps for things such as testing;
private void StringToMapSection(string[] MapStrings, int StartX = 0, int StartY = 0)
{
    for (int y = 0; y < MapStrings.GetUpperBound(0); y++)
    {
        if ((y + StartY) < map.X_Dimension)
            StringToMapSection(MapStrings[y], StartX, StartY);
    }
}

private void SetDefaultRounds(ChangeEventArgs e)
{
    DefaultRounds = Convert.ToBoolean(e.Value);
    if (DefaultRounds)
        UpdateRoundsBasedOnPlayerCount();

}

//private void UpdateRoundsBasedOnPlayerCount(ChangeEventArgs e)
private void UpdateRoundsBasedOnPlayerCount()
{
    //    if(e.Value.GetType() == typeof(int)) {
    //        NumberOfPlayers = Int32.Parse(e.Value.ToString());
    //    }

    switch (NumberOfPlayers)
    {
        case 2:
            NumberOfRounds = 24; break;
        case 3:
            NumberOfRounds = 18; break;
        case 4:
            NumberOfRounds = 12; break;
        case 5:
            NumberOfRounds = 10; break;
        default:
            NumberOfRounds = 12; break;
    }

}

private int SetInitialNumberOfRounds()
{
    if ((NumberOfPlayers == 5) && (NumberOfMoves == 48))
    {
        NumberOfMoves = 50;
        NumberOfRounds = 10;
    }
    else if ((NumberOfPlayers < 5) && (NumberOfMoves == 50))
    {
        NumberOfMoves = 48;
        NumberOfRounds = NumberOfMoves / NumberOfPlayers;
    }

    return NumberOfRounds;
}

private void InitializeGame()
{
    GameState = GameStates.Initiating;

    //ReDim Map
    //My = new string[X_dimension, Y_dimension];
    map = new Map(X_dimension, Y_dimension);

    //Load Test Names
    //    LoadTestGamePlayerNames();

    // Randomize who starts game first
    FirstPlayer = rand.Next(0, NumberOfPlayers - 1);
    GameRound = 1;
    //    if (NumberOfPlayers == 5)
    //        NumberOfMoves = 50; // 48 is the usual count, but not divisible by 5

    //Mild deviation from the original - reset player numbers to put who ever goes first as player 1

    // Initialize Players
    GameStateObj.NumberOfPlayers = NumberOfPlayers;

    int nameIndex = FirstPlayer;
    for (int l = 1; l <= GameStateObj.NumberOfPlayers; l++)
    {
        // Start each Player with some $
        Players.Add(l, new Player(PlayerName[nameIndex], PlayerStartingMoney));
        nameIndex = (nameIndex < (GameStateObj.NumberOfPlayers - 1) ? nameIndex + 1 : 0);
    }

    // Initialize Companies
    for (int companyIndex = 1; companyIndex <= Max_Companies; companyIndex++)
    {
        Companies.Add(companyIndex, new Company(companyIndex, GameStateObj.NumberOfPlayers));
    }

    //Initialize Map with empty sectors
    for (int y = 0; y <= map.Y_Dimension; y++)
    {
        for (int x = 0; x <= map.X_Dimension; x++)
        {
            int sectortype = rand.Next(1, 100);

            if ((StarChance > 0) && (BlackholeChance > 0))
            {
                if (sectortype <= StarChance)
                    map[x, y] = Map.StarSector;
                else if (sectortype <= (StarChance + BlackholeChance))
                    map[x, y] = Map.BlackholeSector;
                else
                    map[x, y] = Map.EmptySector;
            }
            else if (StarChance > 0)
            {
                if (sectortype <= StarChance)
                    map[x, y] = Map.StarSector;
                else
                    map[x, y] = Map.EmptySector;
            }
            else
                map[x, y] = Map.EmptySector;

        }
    }

    // Initialize Stock Holdings
    StockHoldings = new int[Max_Companies, NumberOfPlayers];

    //    TestGame1();

    AvailableMoves = GenerateMoves();
    AddMovesToMap();
    GameState = GameStates.PlayerMove;

    LogGameEvent("The Game has begun!");

}

public int AvailableMoneyForStockBuying()
{
    return AvailableMoneyForStockBuying(0); // pass a 0 to indicate not to exclude any company;
}

public int AvailableMoneyForStockBuying(int ExcludeCompanyId)
{
    int availableMoney = Players[PlayerTurn].Money;
//    Console.WriteLine("StockToBuy.Length=" + GameStateObj.StockToBuy.Length + " ExcludeId = " + ExcludeCompanyId.ToString());
//    foreach (int i in GameStateObj.StockToBuy)
    for (int i = GameStateObj.StockToBuy.GetLowerBound(0); i <= GameStateObj.StockToBuy.GetUpperBound(0); i++)
    {
        if (i != ExcludeCompanyId && Companies.ContainsKey(i) && Companies[i].IsActive)
        {
 //           Console.Write(Companies[i].Symbol + "=" + GameStateObj.StockToBuy[i]);
            availableMoney -= GameStateObj.StockToBuy[i] * Companies[i].ShareValue;
 //           Console.Write("(" + availableMoney.ToString() + ")");
        }
    }

    Console.WriteLine();
    return availableMoney;
}

    public int MaxCanBuy(int CompanyKey)
    {
        return Convert.ToInt32(Math.Floor(AvailableMoneyForStockBuying(CompanyKey) / (double)Companies[CompanyKey].ShareValue));
    }

    public void ExecuteStockTrades()
    {
        for (int i = 0; i <= GameStateObj.StockToBuy.Length; i++)
        {
            if (Companies.ContainsKey(i) && Companies[i].IsActive && (GameStateObj.StockToBuy[i] > 0))
            {
                BuyStock(PlayerTurn, i, GameStateObj.StockToBuy[i]);
            }
        }
    }

    private int BuyStock(int playerId, int companyId, int shares)
    {
        //int shares = 1;

        //Determine if the player has enough money
        if (Players[playerId].Money >= (shares * Companies[companyId].ShareValue))
        {
            //Buy shares
            Players[playerId].Money -= (shares * Companies[companyId].ShareValue);  // Take away the money
            Companies[companyId].StockHolderShares[playerId] += shares; // Add the shares
        }
        else
            shares = 0; // no shares bought

        return shares;
    }

    [Obsolete("Selling not exercised in this version", true)]
    private int SellStock(int playerId, int companyId, int shares)
    {
        // Determine if player has that many shares to sell, if trying to sell more than have, sell all
        if (Companies[companyId].StockHolderShares[playerId] < shares)
            shares = Companies[companyId].StockHolderShares[playerId];

        // Sell the stock
        Players[playerId].Money += (shares * Companies[companyId].ShareValue); // Give the money
        Companies[companyId].StockHolderShares[playerId] -= shares;

        return shares;
    }

    private void GetMoves()
    {
        AvailableMoves = GenerateMoves();
    }

    private void AddMovesToMap()
    {
        foreach (var m in AvailableMoves)
        {
            map[m.Value.X, m.Value.Y] = m.Key.ToString();
        }
    }

    private void RemoveMovesFromMap()
    {
        foreach (Move m in AvailableMoves.Values)
        {
            map[m.X, m.Y] = Map.EmptySector;
        }
    }

    private Dictionary<int, Move> GenerateMoves()
    {
        int x_move;
        int y_move;
        //MoveOutcome move_outcome;

        SortedDictionary<string, Move> tempMoves = new SortedDictionary<string, Move>();

        int existingCompanies = Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value).Count;

        // Find open moves
        for (int l = 1; l <= NumberOfMoves; l++)
        {
            // Find an open move
            bool moveisgood = false;
            do
            {
                x_move = rand.Next(0, map.Sectors.GetUpperBound(0));
                y_move = rand.Next(0, map.Sectors.GetUpperBound(1));
                //move_outcome = DetermineOutcome(x_move, y_move);

                // Make sure sector is empty;
                moveisgood = (map[x_move, y_move] == Map.EmptySector);
                Console.WriteLine(x_move.ToString() + "," + y_move.ToString() + "=" + map[x_move, y_move]);

                // Make sure move isn't already in list
                foreach (Move m in tempMoves.Values)
                {
                    if ((m.X == x_move) && (m.Y == y_move))
                        moveisgood = false;
                }

                // prevent creation of too many companies
                if (existingCompanies == Max_Companies)
                {
                    // check if move will create new company
                    if (DetermineMoveOutcome(x_move, y_move) == MoveOutcome.StartNewCompany)
                        moveisgood = false;
                }

            } while (!moveisgood);

            // Add move to the list of available moves
            Move nm = new Move(x_move, y_move);
            tempMoves.Add(nm.ToString(), nm);
        }

        //Take the sorted dictionary and re-key to numeric index
        Dictionary<int, Move> moves = new Dictionary<int, Move>();
        foreach (Move mv in tempMoves.Values)
            moves.Add(moves.Count + 1, mv);

        // Ensure Map Display -- ADD CODE to mode this to a controller most likely
        GameState = GameStates.PlayerMove;
        StateHasChanged();

        //return moves;
        return moves;
    }

    public void MakeMove(int moveNumber)
    {
        Move move = AvailableMoves[moveNumber];

        //Update Status
        GameStatus = "Player " + PlayerTurn.ToString() + " opens up sector " + move.ToString();
        // Update map with new status based on move
        RemoveMovesFromMap();
        map[move.X, move.Y] = Map.DevelopedSector;

        GameState = GameStates.PlayerStockPurchasing;

        // Calculate results of the move
        ExecuteMove(move.X, move.Y, map);

        //Advance Game
        GameState = GameStates.PlayerStockPurchasing;

    }


    private void EndTurn()
    {
        //Buy Stocks
        ExecuteStockTrades();
        GameStateObj.ResetStockExchange();
        StateHasChanged();

        // Increment Turn
        if (NextPlayerTurn())
            PayDividends();

        if (GameRound > NumberOfRounds)
        {
            GameState = GameStates.GameEnding;
        }
        else
        {
            GameState = GameStates.PlayerMove;

            //Generate the moves for the next player
            AvailableMoves = GenerateMoves();
            AddMovesToMap();
        }
    }

    private void PayDividends()
    {
        foreach (var p in Players)
        {
            p.Value.Money += (int)Math.Round(PlayerStockWorth(p.Key) * (double)DividendPercentage / 100);
        }
    }

    @* Returns True if new round *@
    private bool NextPlayerTurn()
    {
        PlayerTurn++;
        if (PlayerTurn > NumberOfPlayers)
        {
            PlayerTurn = 1;
            GameRound++;
            return true;
        }
        else { return false; }
    }

    private string SectorClass(string sectorValue)
    {
        switch (sectorValue)
        {
            case Map.NullSector:
                return "map-sector-null";
            case Map.EmptySector:
                return "map-sector-empty";
            case Map.DevelopedSector:
                return "map-sector-developed";
            case Map.StarSector:
                return "map-sector-star";
            case Map.BlackholeSector:
                return "map-sector-blackhole";
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
                return "map-sector-move";
        }

        if ("ABCDEFGHIJKL".Contains(sectorValue)) return "map-sector-company";

        return String.Empty;
    }

    //prints the map using text string - for debugging purposes only
    public string PrintMap()
    {
        return map.PrintMap(GameState == GameStates.PlayerMove, AvailableMoves);
    }

    public int CalculateAdjacentSectorValue(string sectorstate)
    {
        switch (sectorstate)
        {
            case Map.StarSector:
                return StarValue;
            case Map.BlackholeSector:
                return 0;
            default:
                return 0;
        }
    }

    public int CalculateSharePrice(Company company)
    {
        int value = 0;

        for (int x = 0; x <= map.X_Dimension; x++)
        {
            for (int y = 0; y <= map.Y_Dimension; y++)
            {
                if (map[x, y] == company.Symbol)    //if the company owns this sector
                {
                    value += 100; // for the sector itself
                    string[] neighbors = map.GetNeighbors(x, y);
                    foreach (string s in neighbors)
                    { value += CalculateAdjacentSectorValue(s); }
                }
            }
        }

        return value;
    }


    public int CompanySize(Company company)
    {
        return map.NumberOfSymbolsOnMap(company.Symbol);
    }

    public int PlayerStockWorth(int playerid)
    {
        int stockvalue = 0;
        foreach (Company c in Companies.Values)
        {
            stockvalue += c.StockHolderShares[playerid] * c.ShareValue;
        }
        return stockvalue;
    }

    public int PlayerNetWorth(int playerid)
    {
        return Players[playerid].Money + PlayerStockWorth(playerid);
    }

    public MoveOutcome DetermineMoveOutcome(int x, int y)
    {
        {
            // evalute nearby spaces to determine outcome of this move
            MoveOutcome moveOutcome = MoveOutcome.DevelopSector;

            //initialize adjacent locals
            string[] neighbors = map.GetNeighbors(x, y);
            List<string> adjacentCompanies = map.AdjacentCompanies(x, y);


            // Check for adjacent companies
            if (adjacentCompanies.Count == 0)
            {
                // If it's all empty sectors nearby
                if (String.Join("", neighbors) == new String('x', 4).Replace("x", Map.EmptySector))
                {
                    moveOutcome = MoveOutcome.DevelopSector;
                }

                // Check for creation of new company
                if ((String.Join("", neighbors).Contains(Map.StarSector)) || (String.Join("", neighbors).Contains(Map.DevelopedSector)))
                {
                    moveOutcome = MoveOutcome.StartNewCompany;
                }
            }
            // Check for expansion of company
            else if (adjacentCompanies.Count == 1)
            {
                moveOutcome = MoveOutcome.ExpandCompany;
            }
            // Check for Merger
            else if (adjacentCompanies.Count > 1)
            {
                moveOutcome = MoveOutcome.Merger;
            }

            //Check for black hole
            if (BlackholeChance > 0)
            {
                if (String.Join("", neighbors).Contains(Map.BlackholeSector))
                {
                    moveOutcome = MoveOutcome.Blackhole;
                }
            }

            return moveOutcome;
        }
    }

    public MoveOutcome ExecuteMove(int x, int y, Map theMap)
    {
        // evalute nearby spaces to determine outcome of this move
        MoveOutcome moveOutcome = MoveOutcome.DevelopSector; //default

        //initialize adjacent locals
        string[] neighbors = theMap.GetNeighbors(x, y);
        List<string> adjacentCompanies = theMap.AdjacentCompanies(x, y);

        // Develop Sector
        theMap[x, y] = Map.DevelopedSector;

        // Check for adjacent companies
        if (adjacentCompanies.Count == 0)
        {
            // If it's all empty sectors nearby
            if (String.Join("", neighbors) == new String('x', 4).Replace("x", Map.EmptySector))
            {
                // Develop Sector
                theMap[x, y] = Map.DevelopedSector;
            }

            // Check for creation of new company
            if ((String.Join("", neighbors).Contains(Map.StarSector)) || (String.Join("", neighbors).Contains(Map.DevelopedSector)))
            {
                // Make a new company
                moveOutcome = MoveOutcome.StartNewCompany;
                int newCo = AvailableCompanySlot();

                if (newCo == 0)
                { } // ?? Shouldn't end up here, no more companies available! ADD CODE to handle this?

                // Open up the new company
                Companies[newCo].OpenCompany(PlayerTurn, FounderShares);
                theMap[x, y] = Companies[newCo].Symbol;

                // Expand into any adjacent developed sectors
                if (neighbors[0] == Map.DevelopedSector)
                    theMap[x, y - 1] = Companies[newCo].Symbol;
                if (neighbors[1] == Map.DevelopedSector)
                    theMap[x - 1, y] = Companies[newCo].Symbol;
                if (neighbors[2] == Map.DevelopedSector)
                    theMap[x + 1, y] = Companies[newCo].Symbol;
                if (neighbors[3] == Map.DevelopedSector)
                    theMap[x, y + 1] = Companies[newCo].Symbol;

                LogGameEvent("NEW COMPANY!", Players[PlayerTurn].Name + " has founded a new company, " + Companies[newCo].Name + ".");
            }
        }
        // Check for expansion of company
        else if (adjacentCompanies.Count == 1)
        {
            //Expansion
            moveOutcome = MoveOutcome.ExpandCompany;

            // Expand into "move" sector
            theMap[x, y] = adjacentCompanies[0];

            // Expand into any developed adjacent sectors
            if (neighbors[0] == Map.DevelopedSector)
                theMap[x, y - 1] = adjacentCompanies[0];
            if (neighbors[1] == Map.DevelopedSector)
                theMap[x - 1, y] = adjacentCompanies[0];
            if (neighbors[2] == Map.DevelopedSector)
                theMap[x + 1, y] = adjacentCompanies[0];
            if (neighbors[3] == Map.DevelopedSector)
                theMap[x, y + 1] = adjacentCompanies[0];
        }
        // Check for Merger
        else if (adjacentCompanies.Count > 1)
        {
            //Merger!
            moveOutcome = MoveOutcome.Merger;

            //Sort companies by alpabetical
            adjacentCompanies.Sort();

            string foo = String.Empty;

            // Add the symbol and the size to a dictionary to iterate
            Dictionary<string, int>
                coS = new Dictionary<string, int>
                    ();
            foreach (string s in adjacentCompanies)
            {
                coS.Add(s, CompanySize(Companies[Company.KeyFromSymbol(s)]));
                foo += s + "=" + coS[s] + ", ";
            }

            string survivor = string.Empty;

            // Merge largest and smallest companies, until we're down to just one company
            do
            {
                int winner = 0;
                for (int i = 1; i < coS.Count; i++)
                {
                    if (coS.ElementAt(i).Value > coS.ElementAt(winner).Value)
                        winner = i;
                }

                survivor = coS.ElementAt(winner).Key;

                int loser = coS.Count - 1;
                for (int i = coS.Count - 2; i >= 0; i--)
                {
                    if (coS.ElementAt(i).Value < coS.ElementAt(loser).Value)
                        loser = i;
                }

                // merge winner and loser
                MergeCompanies(Companies[Company.KeyFromSymbol(coS.ElementAt(winner).Key)], Companies[Company.KeyFromSymbol(coS.ElementAt(loser).Key)]);

                string winnerName = Companies[Company.KeyFromSymbol(coS.ElementAt(winner).Key)].Name;
                string loserName = Companies[Company.KeyFromSymbol(coS.ElementAt(loser).Key)].Name;
                LogGameEvent("MERGER!!!!!", $"{winnerName} and {loserName} have merged! The unified company will now be known as {winnerName}.");

                //remove loser
                coS.Remove(coS.ElementAt(loser).Key);
            } while (coS.Count > 1);

            // Update the newly developed sector that created the merger
            theMap[x, y] = survivor;

            StateHasChanged();
        }

        //Check for black hole(s), that could wipe out any newly merged or expanded companies!
        if (BlackholeChance > 0)
        {
            for (int x_loop = 0; x_loop <= theMap.X_Dimension; x_loop++)
            {
                for (int y_loop = 0; y_loop <= theMap.Y_Dimension; y_loop++)
                {
                    if (theMap[x_loop, y_loop] == Map.BlackholeSector)
                    {
                        //Wipe out companies that touched the blackhole!
                        adjacentCompanies = theMap.AdjacentCompanies(x_loop, y_loop);
                        if (adjacentCompanies.Count > 0)
                        {
                            foreach (string c in adjacentCompanies)
                            {
                                theMap.ReplaceSymbolOnMap(Companies[Company.KeyFromSymbol(c)].Symbol, Map.EmptySector);
                                Companies[Company.KeyFromSymbol(c)].CloseCompany();

                                LogGameEvent("DISASTER!", Companies[Company.KeyFromSymbol(c)].Name + " sucked into black hole at Sector " + Move.ToString(x_loop, y_loop));
                            }
                        }

                        //Randomly destroy developed sectors next to blackholes
                        string[] blackholeNeighbors = theMap.GetNeighbors(x_loop, y_loop);
                        for (int n = 0; n < blackholeNeighbors.GetUpperBound(0); n++)
                        {
                            if (blackholeNeighbors[n] == Map.DevelopedSector)
                            {
                                if (rand.Next(1, 100) <= BlackholeConsumptionChance)
                                {
                                    // Destroy the sector
                                    int x_destroyed = x_loop;
                                    int y_destroyed = y_loop;
                                    if (n == 0) { y_destroyed = y_loop - 1; }
                                    if (n == 1) { x_destroyed = x_loop - 1; }
                                    if (n == 2) { x_destroyed = x_loop + 1; }
                                    if (n == 3) { y_destroyed = y_loop + 1; }


                                    // The sector just developed on this turn cannot be destroyed on the same turn
                                    if ((x != x_destroyed) && (y != y_destroyed))
                                    {
                                        theMap[x_destroyed, y_destroyed] = Map.NullSector;
                                        LogGameEvent("Sector " + Move.ToString(x_destroyed, y_destroyed) + " consumed by black hole!");
                                    }
                                }
                            }
                        }
                    }
                }
            }

        }

        // Calculate the final share prices
        foreach (Company company in Companies.Values)
        {
            company.ShareValue = CalculateSharePrice(company);
        }

        //Force redraw of maps
        StateHasChanged();  // Since our map display is a set of string, it does not seem to force a refresh for changes to Map array

        return moveOutcome;
    }



    public void MergeCompanies(Company winner, Company loser)
    {
        //Update Map
        map.ReplaceSymbolOnMap(loser.Symbol, winner.Symbol);

        // Trade in old stock
        foreach (var item in loser.StockHolderShares)
        {
            winner.StockHolderShares[item.Key] += (item.Value / 2); // Award at 2 old for 1 new
            Players[item.Key].Money += ((item.Value % 2) * loser.ShareValue); // Pay out remainer share
        }

        // Close down prior company
        loser.CloseCompany();
    }

    public int AvailableCompanySlot()
    {
        foreach (var item in Companies)
        {
            if (!item.Value.IsActive) return item.Key;
        }

        return 0;   // no available company slots
    }

    private string EventsText()
    {
        //List events in reverse chronological order
        return String.Join("<br/>", Events.ToArray().Reverse());
    }

    private void LogGameEvent(string eventText)
    {
        LogGameEvent("", eventText);
    }

    private void LogGameEvent(string eventHeader, string eventText)
    {
        if (Events.Count >= 10)
            Events.Dequeue();
        Events.Enqueue("Round " + GameRound.ToString() + "&raquo; " + eventHeader + " " + eventText);
    }

    private int PlayerRank(int playerId)
    {
        int rank = 1;
        int netWorth = PlayerNetWorth(playerId);
        for (int i = 1; i <= Players.Count; i++)
        {
            int iNetWorth = PlayerNetWorth(i);
            if (iNetWorth > netWorth)       // Tie breaker one: Net Worth
                rank++;
            else if (iNetWorth == netWorth)
                if (PlayerStockWorth(i) > PlayerStockWorth(playerId)) // Tie breaker two: Stock value
                    rank++;
                else if (playerId < i)  // Tie breaker three: player who had later move is considered disadvantaged, so gets ranked higher
                    rank++;
        }

        return rank;
    }

    private int[] PlayerRanks()
    {

        Dictionary<int, int> NetWorths = new Dictionary<int, int>();

        foreach (var p in Players)
        {
            NetWorths.Add(p.Key, PlayerNetWorth(p.Key));
        }

        int[] ranks = new int[NumberOfPlayers];
        NetWorths.OrderByDescending(p => p.Value).ToArray().CopyTo(ranks, 0);

        return ranks;
    }
}

