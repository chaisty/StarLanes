@page "/starlanesgame"

<div class="row">
    <h1>Star Lanes</h1>
</div>
@*
    <p>Current size: @(X_dimension)x@(Y_dimension) </p>
    <p>Current UBounds: @(Map.GetUpperBound(0))x@(Map.GetUpperBound(1)) </p>
*@

@if (GameState == GameStates.NotStarted)
{
    <p>
        <label for="numberOfPlayers"># of Players:</label> <input id="numberOfPlayers" type="number" min="2" max="@Max_NumberOfPlayers" @bind="NumberOfPlayers" />
    </p>
    <p>
        @for (int p = 1; p <= NumberOfPlayers; p++)
        {

            var pa = p - 1;
            @*<span class="text-danger">@_playerNameValidationMessage(p))</span>*@
            <label for="playerName(@p)">Player @p Name:</label> <input id="playerName(@p)" type="text" minlength="2" maxlength="20" @bind="PlayerName[pa]" />
            <label for="computerPlayer(@p)" style="font-size: small;">Computer Player<input type="checkbox" id="computerPlayer(@p)" @bind="ComputerPlayer[pa]" /> </label>
            <br />
        }
    </p>

    <div class="form-check-inline"><label><input type="radio" class="form-check-input" name="gameformat" value="standard" checked @onchange="(e) => SetMapSize(12,9)">Standard Game (12x9)</label></div>
    <div class="form-check-inline"><label><input type="radio" class="form-check-input" name="gameformat" value="large" @onchange="(e) => SetMapSize(16,12)">Big Game (16x12)</label></div>
    <div class="form-check-inline"><label><input type="radio" class="form-check-input" name="gameformat" value="jumbo" @onchange="(e) => SetMapSize(20,16)">Jumbo Game (20x16)</label></div>

    <p>
        <button class="btn btn-primary" @onclick="InitializeGame">Start Game!</button>
    </p>

    @*
        <div id="AdvOptionsAccordion">
            <div class="card">
                <div class="card-header" id="AdvOptionsHeader">
                    <h5 class="mb-0">
                        <button class="btn btn-link" data-toggle="collapse" data-target="#AdvOptions" aria-expanded="true" aria-controls="AdvOptions">
    *@

    <p>
        <button @onclick="(e) => ToggleAdvancedOptions()" class="btn btn-outline-secondary" data-toggle="buttons">
            @(AdvancedOptionsVisible ? "Hide" : "Show") Advanced Options
        </button>
    </p>

    @if (AdvancedOptionsVisible)
    {
        <div id="AdvOptions" class="collapse show" visible>

            @*   <div id="AdvOptions" class="collapse show" aria-labelledby="AdvOptionsHeader" data-parent="#AdvOptionsAccordion"> *@

            <label for="NumberOfCompanies">Max # of Companies: </label><input id="NumberOfCompanies" type="number" min="5" max="@Max_NumberOfCompanies" @bind="NumberOfCompanies" /> (5-10, default 5)<br />
            <label for="MapSize">Map Size: </label><input id="MapSizeX" type="number" min="6" max="20" @bind="X_dimension" /> x <input id="MapSizeY" type="number" min="5" max="20" @bind="Y_dimension" /> (Min 6x5, Normal 12x9, Max 20x20, default 12x9)<br />
            <label for="StarLikelihood">Star Likelihood: </label><input id="StarLikelihood" type="number" min="0" max="15" @bind="StarChance" />% (0-15, default 10)<br />
            <label for="BlackholeLikelihood">Black Hole Likelihood: </label><input id="BlackholeLikelihood" type="number" min="0" max="5" @bind="BlackholeChance" />% (0-5, default 3)<br />
            <label for="BlackholeConsumptionChance">Black Hole Consumption %: </label><input id="BlackholeConsumptionChance" type="number" min="0" max="100" @bind="BlackholeConsumptionChance" /> (0-100, default 25, applies to developed sectors, not companies)<br />
            @*<label for="StartingOrder">Starting Player:</label><br />*@
            <input type="checkbox" name="RandomizeWhoGoesFirst" @bind="RandomizeFirstMover" /><label for="RandomizeWhoGoesFirst">Randomize Who Goes First</label> <br/>
            <label for="FounderShares">Founder Shares: </label><input type="number" id="NumFounderShares" min="0" max="20" @bind="FounderShares" /> (0-20, default 5)<br />
            <label for="StartingMoney">Starting Money: </label><input type="number" id="AmountStartingMoney" min="1000" max="10000" @bind="PlayerStartingMoney" /> (1,000-20,000, default 6,000)<br />
            <label for="DividendsPercentage">Dividends %: </label><input id="DividendsPercentage" type="number" min="1" max="10" @bind="DividendPercentage" />% (1-10, default 5)<br />
            <label for="MergerRatio">Merger Ratio: </label><input id="MergerRatio" type="number" min="1" max="5" @bind="MergerRatio" /> (1-5, default 2, number of shares of smaller merged company to equal 1 in new company)<br />
            <label for="SectorValue">Sector Value $: </label><input id="SectorValue" type="number" min="0" max="500" step="100" @bind="NormalValue" /> (0-500, 100 default) <br />
            <label for="StarSectorValue">Star Sector Value $: </label><input id="StarSectorValue" type="number" min="0" max="2000" step="100" @bind="StarValue" /> (0-2000, 500 default) <br />
            <label for="BlackholeDestructive">Blackhole Destroys: </label><input id="BlackholeDestroys" type="checkbox" @bind="BlackholeDestroys" /> (If false, Blackhole adjacency only penalizes stock value)<br />
            <label for="BlackholeSectorValue">Blackhole Sector Value $: </label><input id="BlackholeSectorValue" disabled="@(BlackholeDestroys)" type="number" min="-2000" max="0" step="100" @bind="BlackholeValue" /> (-2000-0, 0 default) <br />
            <label for="NumberOfRounds"># of Rounds: </label><input checked id="defaultRoundsByPlayerCount" type="checkbox" @onchange="(e) => { SetDefaultRounds(e); }" /> Use Default <input disabled="@(DefaultRounds)" id="NumberOfRounds" type="number" min="1" max="24" @bind="NumberOfRounds" /> (1-24, default based on number of players with 48-50 total turns)<br />
            <label for="AvailableMovesPerTurn"># of Available Moves: </label><input id="AvailableMovesPerTurn" type="number" min="4" max="5" @bind="NumberOfMoves" /> (3-5, default 4)<br />

        </div>
    }

}

@if ((GameState != GameStates.NotStarted) && (GameState != GameStates.GameEnding))
{

    @* Game Status Header *@
    <div class="row">
        <div class="col-3 header-round">
            Round @(GameRound) of @(NumberOfRounds)
        </div>
        @* Show whose turn it is *@
        <div class="col-9 turn-instructions-panel">
            <p>
                <label style="font-weight:bold">@(Players.ContainsKey(PlayerTurn) != true ? "" : Players[PlayerTurn].Name + "'s") Turn: </label>
                <label>
                    @((MarkupString)(GameState == GameStates.PlayerMove ? "<b>Move<b> >" : "Move > "))
                    @((MarkupString)(GameState == GameStates.PlayerStockPurchasing ? "<b>Stock Buying<b> > " : "Stock Trading > "))
                    End Turn
                </label>
            </p>
        </div>
    </div>

    @* Show player status *@
    <div class="container row justify-content-center player-status-panel">
        <div>
            @foreach (var p in Players)
            {

                <div class="container player-status-box @(PlayerTurn == p.Key ? "player-status-box-active" : "")">
                    <div class="player-status-box-name @(PlayerTurn == p.Key ? "player-status-name-active" : "")">
                        @(p.Value.Name + " ["+ PlayerRank(p.Key) + "]") @((MarkupString)PlayerIcon(p.Key)) 
                    </div>
                    <div class="player-status-box-money">
                        Bank: @("$" + p.Value.Money.ToString())
                    </div>
                    <div class="player-status-box-stocks">
                        @foreach (var c in Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value))
                        {
                            @((MarkupString)(c.Value.Symbol + ":&nbsp;" + c.Value.StockHolderShares[p.Key].ToString() + "&nbsp;&nbsp; "))
                        }
                    </div>
                    <div class="player-status-box-networth">
                        @(("Net Worth: $" + PlayerNetWorth(p.Key)))
                    </div>
                </div>
            }
        </div>
    </div>

    <div class="container row event-panel clearfix" style="width: 100%; height: 100px; margin: 25px 0px;">
        <div class="col-2 event-panel-title">
            Universal Newswire
        </div>
        <div class="col-10 event-panel-readout overflow-auto">
            @((MarkupString)EventsText())
        </div>
    </div>

    <div class="container-fluid clearfix">
        <div class="row" style="height:400px">
            @* Container for side-by-side map and newswire*@

            @* Map Display *@
            <div class="map-panel">
                <div class="map" style="float:left;">
                    <div class="map-title">Map of the Universe</div>
                    <div class="map-title">@((String.Concat(Enumerable.Repeat("*", X_dimension * 3 - 2))))</div>
                    <div class="map-sectors">
                        <div class="map-x-axis" style="clear: both;">
                            <div class="map-sector">&nbsp;</div>
                            @for (int x = 0; x <= map.X_Dimension; x++)
                            {
                                <div class="map-sector map-axis map-x-axis">@((char)(x + 65))</div>
                            }
                        </div>

                        @for (int y = 0; y <= map.Y_Dimension; y++)
                        {
                            <div style="clear: both;">
                                <div class="map-sector map-axis map-y-axis" style="float: left; clear: none">@(y + 1)</div>
                                @for (int x = 0; x <= map.X_Dimension; x++)
                                {
                                    <div class="map-sector @(SectorClass(map[x, y]))">@(map[x, y])</div>
                                }
                            </div>
                        }
                    </div>

                </div>

            </div>

            <div class="player-actions">
                <fieldset id="playeractionelements" disabled="@(!(Players[PlayerTurn].IsHuman))">
                    @* Stock purchasing buttons*@

                    @if (GameState == GameStates.PlayerStockPurchasing)
                    {
                        @* if there are any companies *@
                        @if (Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value).Count > 0)
                        {
                            <div class="clearfix">
                                <span class="bold-small-header">Buy Stocks with $@(Players[PlayerTurn].Money) ($@(AvailableMoneyForStockBuying()) unallocated)</span>
                            </div>
                            <div class="clearfix">
                                @foreach (var c in Companies)
                                {
                                    @if (c.Value.IsActive)
                                    {
                                        <div class="row stock-to-buy-box">
                                            <div class="w-auto">
                                                <label>@(c.Value.Name)&nbsp;</label>
                                            </div>
                                            <div class="w-auto">
                                                <label for="Buy=@(c.Key)">$@(c.Value.ShareValue) x </label>
                                                <input id="Buy=@(c.Key)" style="width:3em" type="number" @bind="GameStateObj.StockToBuy[c.Key]" min="0" max="@(MaxCanBuy(c.Key))" />
                                                <button class="btn btn-secondary btn-xs" @onclick="() => { GameStateObj.StockToBuy[c.Key] = MaxCanBuy(c.Key); }">Max</button>
                                            </div>
                                        </div>
                                        @*                     <button class="btn btn-secondary btn-xs" onclick="alert(" onclick="document.getElementById("Buy=@(c.Key)").value = document.getElementById("Buy=@(c.Key)").attr('max');";">Max</button> *@

                                        @*
                                <label class="player-actions-buysellstock">@(c.Value.Name)</label>
                                <button class="btn btn-outline-secondary btn-xs" disabled="@(GameState != GameStates.PlayerStockPurchasing)" @onclick="(e => { BuyStock(PlayerTurn, c.Key, 1); })"> + </button>
                                <span class="btn btn-outline-secondary btn-sm">@(c.Value.StockHolderShares[PlayerTurn])</span>
                                <button class="btn btn-outline-secondary btn-xs" disabled="@(GameState != GameStates.PlayerStockPurchasing)" @onclick="(e => { SellStock(PlayerTurn, c.Key, 1); })"> - </button>
                                        *@
                                    }
                                }
                            </div>

                        }
                        else @* no companies *@
                        {
                            <div>
                                No companies available for stock purchasing
                            </div>
                        }
                        @* End Turn Button for Humans Players *@
                        <div style="text-align: center; margin: 10px 0px; align-self:flex-end">
                            <button class="btn btn-secondary" disabled="@(GameState != GameStates.PlayerStockPurchasing)" @onclick="(e => { EndTurn(); })">@(Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value).Count > 0 ? "Buy Stocks & Complete Turn" : "End Turn")</button>
                        </div>

                    }

                    @* Available Move Buttons *@
                    <div class="player-moves-panel">
                        @if (GameState == GameStates.PlayerMove)
                        {
                            <div class="player-moves-title">Available Moves:</div>
                            @foreach (var move in AvailableMoves)
                            {
                                <button class="btn btn-outline-secondary move-button" hidden="@(GameState != GameStates.PlayerMove)" disabled="@(GameState != GameStates.PlayerMove)" @onclick="(e => { MakeMove(move.Key); })">@(move.Value)</button>
                            }
                            <div>
                                @* if this is testing, allow for the player to regenerate the available moves *@
                                @if (GameStateObj.TestGame)
                                {
                                    <button class="btn btn-primary" @onclick="(e => { RemoveMovesFromMap(); AvailableMoves = GenerateMoves(); AddMovesToMap(); })">GenerateMoves</button>
                                }
                            </div>
                        }
                    </div>
                </fieldset>
                @* End Turn Button for Human to continue game after Computer Turn *@
                @if ((GameState == GameStates.PlayerStockPurchasing) && (!Players[PlayerTurn].IsHuman))
                {
                    <div style="text-align: center; margin: 10px 0px; align-self:flex-end">
                        <button class="btn btn-primary" @onclick="(e => { EndTurn(); })"> Next Turn </button>
                    </div>
                }
            </div>
        </div>
    </div>

    @* Map Display *@
    @*
        <div class="map-panel">
            <div class="map">
                <label>@((MarkupString)(String.Concat(Enumerable.Repeat("&nbsp", Convert.ToInt32(Math.Floor((double)(2 + X_dimension * 3 - 1 - MapTitle.Length) / 2.0))))))@MapTitle</label><br />
                <label>@((MarkupString)("&nbsp&nbsp" + (String.Concat(Enumerable.Repeat("*", X_dimension * 3 - 2)))))</label><br />
                <label>@((MarkupString)PrintMap())</label>
            </div>
        </div>
    *@
    @*
        <div class="clearfix">
    *@

    @* Show event readout *@
    @*
            <div class="event-panel" style="float:left margin: 0px 50px 0px 0px;">
                <div class="event-panel-title">
                    Universal Newswire
                </div>
                <div class="event-panel-readout">
                    @((MarkupString)EventsText())
                </div>
            </div>
        </div>
    *@
    @* Show company status *@
    <div class="company-status-panel">

        @* Leftmost box is column names *@
        <div class="company-status-key">
            <div class="company-status-box-name">
                Company:
            </div>
            <div class="company-status-box-sharevalue">
                Share Value($):
            </div>
            <div class="company-status-box-sharesoutstanding">
                Outstanding Shares:
            </div>
            <div class="player-status-box-size">
                # of Sectors:
            </div>
        </div>

        @foreach (var c in Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value))
        {
            <div class="company-status-box">
                <div class="company-status-box-name">
                    @(c.Value.Name)
                </div>
                <div class="company-status-box-sharevalue">
                    @(c.Value.ShareValue.ToString())
                </div>
                <div class="company-status-box-sharesoutstanding">
                    @(c.Value.OutstandingShares())
                </div>
                <div class="company-status-box-size">
                    @(CompanySize(c.Value))
                </div>
            </div>
        }

    </div>
}

@if (GameState == GameStates.GameEnding)
{
    <h2>The Game is over!</h2>

    <p>After @((NumberOfRounds <= GameRound) ? NumberOfRounds : GameRound) Round@((NumberOfRounds > 1) ? "s" : "")...</p>
    <h3>@(Players[GameStateObj.Winner].Name) is the winner!</h3>
    <table class="table">
        <tr>
            <th>Rank</th>
            <th>Player</th>
            <th>Stock</th>
            <th>Cash</th>
            <th>Net Worth</th>
        </tr>
        @foreach (var p in Players.OrderBy(r => r.Value.FinalRank))
        {
            <tr class="@( (PlayerRank(p.Key) == 1) ? "table-primary" : "" )" style="@((PlayerRank(p.Key) == 1) ? "font-weight: 700" : "")">
                <th>@(PlayerRank(p.Key))</th>
                <td>@(p.Value.Name)</td>
                <td>$@(PlayerStockWorth(p.Key))</td>
                <td>$@(Players[p.Key].Money)</td>
                <td>$@(PlayerNetWorth(p.Key))</td>
            </tr>
        }
    </table>

}


@code {

        //UI only functions
        private string GenerateControlRef(int Id)
        {
            return "Move" + Id.ToString();
        }

        private string PlayerIcon(int Id)
        {
            if (!Players[Id].IsHuman)
                return "<img src=" + (char)34 + "css/font-awesome/robot.svg" + (char)34 + " width=" + (char)34 + "16" + (char)34 + " height=" + (char)34 + "16" + (char)34 + " alt=" + (char)34 + "C" + (char)34 + " />";
            else
                return "";
        }




    // Initialize Randomizer
    Random rand = new Random();

    //Create Base Objects
    public int[,] StockHoldings = new int[1, 1];    //Redim this later
    public Dictionary<string, int> Stocks = new Dictionary<string, int>();

    // Initialize Companies
    public const int Max_NumberOfCompanies = 10;
    public int Max_Companies = 5;   //configurable
    public int founderShares = 5;
    Dictionary<int, Company> Companies = new Dictionary<int, Company>();

    //Initialize Map
    const int Max_X_dimension = 20;
    const int Max_Y_dimension = 20;
    public int x_dimension = 12;
    public int y_dimension = 9;
    public int starChance = 10;
    public int blackholeChance = 3;
    public int blackholeConsumptionChance = 25; // chance a developed sector will be consumed by a black hole
    public bool blackholeDestroys = true;

    @*public string[,] My = new string[1, 1]; *@
public Map map = new Map(1, 1);

//Initialize Sector Values
public int normalValue = 100;
public int starValue = 500;
public int blackholeValue = 0; // can't build next to them yet, so 0 value will indicate they destroy companies vs. just impair value

//Finance Constants
public int mergerRatio = 2; // Old shares needed to equal one new share
public int playerStartingMoney = 6000;
public int dividendPercentage = 5;

//Initialize Player dictionary
const int Max_NumberOfPlayers = 5;
public int NumberOfPlayers = 4;
string[] PlayerName = new string[Max_NumberOfPlayers];
bool[] ComputerPlayer = new bool[Max_NumberOfPlayers];
Dictionary<int, Player> Players = new Dictionary<int, Player>();


// Game state variables
int PlayerTurn = 1;
//Dictionary<int, string> OldMoves = new Dictionary<int, string>();
Dictionary<int, Move> AvailableMoves = new Dictionary<int, Move>();
string MovesDescription = string.Empty;
string GameStatus = "Not Started.";
public enum GameStates
{
    NotStarted = 0,
    Initiating = 1,
    PlayerMove = 10,
    PlayerStockPurchasing = 15,
    BetweenMoves = 17,
    GameEnding = 20,
    GameEnded = 25
}
public GameStates GameState = GameStates.NotStarted;
public int GameRound = 0;
public bool RandomizePlayerOrder = true;
public bool RandomizeFirstMover = true;
public int FirstPlayer = 0;
public int MaxNumberOfMovesPerGame = 48;
public int numberOfRounds = 12;
public bool DefaultRounds = true;
public int numberOfMoves = 4;  // # of sectors the player is allowed to choose among to develop on his turn

public Queue<string> Events = new Queue<string>();

public bool AdvancedOptionsVisible = false;
private void ToggleAdvancedOptions()
{
    AdvancedOptionsVisible = !AdvancedOptionsVisible;
}


// Game Properties

private void SetMapSize(int x, int y)
{
    X_dimension = x;
    Y_dimension = y;
}

private int NumberOfCompanies
{
    get { return Max_Companies; }
    set
    {
        if (value > 10)
            Max_Companies = 10;
        else if (value < 5)
            Max_Companies = 5;
        else
            Max_Companies = value;
    }
}

private int FounderShares
{
    get { return founderShares; }
    set
    {
        if (value < 0)
            founderShares = 0;
        else if (value > 20)
            founderShares = 20;
        else
            founderShares = value;
    }
}

private int PlayerStartingMoney
{
    get { return playerStartingMoney; }
    set
    {
        if (value < 0) { playerStartingMoney = 0; }
        else if (value > 20000) { playerStartingMoney = 20000; }
        else { playerStartingMoney = value; }
    }
}

private int MergerRatio
{
    get { return mergerRatio; }
    set
    {
        if (value < 1) { mergerRatio = 1; }
        else if (value > 5) { mergerRatio = 5; }
        else { mergerRatio = value; }
    }
}

/*const int NormalValue = 100;
const int StarValue = 500;

//Finance Constants
public int MergerRatio = 2; // Old shares needed to equal one new share
*/

private int NormalValue
{
    get { return normalValue; }
    set
    {
        if (value < 0)
            normalValue = 0;
        else if (value > 1000)
            normalValue = 1000;
        else
            normalValue = value;
    }
}

private int StarValue
{
    get { return starValue; }
    set
    {
        if (value < 0)
            starValue = 0;
        else if (value > 2000)
            starValue = 2000;
        else
            starValue = value;
    }
}

private int BlackholeValue
{
    get { return blackholeValue; }
    set
    {
        if (value < -2000)
            blackholeValue = -2000;
        else if (value > 0)
            blackholeValue = 0;
        else
            blackholeValue = value;
    }
}

private bool BlackholeDestroys
{
    get; set;
}

/*
//Initialize Map
const int Max_X_dimension = 20;
const int Max_Y_dimension = 15;
public int x_dimension = 12;
public int y_dimension = 9;
public int starChance = 10;
public int blackholeChance = 3;
public int blackholeConsumptionChance = 25;
*/

private int X_dimension
{
    get { return x_dimension; }
    set
    {
        if (value < 5)
            x_dimension = 5;
        else if (value > Max_X_dimension)
            x_dimension = Max_X_dimension;
        else
            x_dimension = value;
    }
}

private int Y_dimension
{
    get { return y_dimension; }
    set
    {
        if (value < 5)
            y_dimension = 5;
        else if (value > Max_Y_dimension)
            y_dimension = Max_Y_dimension;
        else
            y_dimension = value;
    }
}

private int StarChance
{
    get { return starChance; }
    set
    {
        if (value < 0)
            starChance = 0;
        else if (value > 20)
            starChance = 20;
        else
            starChance = value;
    }
}

private int BlackholeChance
{
    get { return blackholeChance; }
    set
    {
        if (value < 0)
            blackholeChance = 0;
        else if (value > 5)
            blackholeChance = 5;
        else
            blackholeChance = value;
    }
}

private int BlackholeConsumptionChance
{
    get { return blackholeConsumptionChance; }
    set
    {
        if (value < 0)
            blackholeConsumptionChance = 0;
        else if (value > 100)
            blackholeConsumptionChance = 100;
        else
            blackholeConsumptionChance = value;
    }
}

/*
public int MaxNumberOfMovesPerGame = 48;
public int NumberOfRounds = 12;
public bool DefaultRounds = true;
public int NumberOfMoves = 4;
public int NumberOfAvailableMoves = 4;  // # of sectors the player is allowed to choose among to develop on his turn
*/

private int NumberOfRounds
{
    get { return numberOfRounds; }
    set
    {
        if (value < 1)
            numberOfRounds = 1;
        else if (value > 24)
            numberOfRounds = 24;
        else
            numberOfRounds = value;
    }
}

private int NumberOfMoves
{
    get { return numberOfMoves; }
    set
    {
        if (value < 3)
            numberOfMoves = 3;
        else if (value > 5)
            numberOfMoves = 5;
        else numberOfMoves = value;
    }
}

private int DividendPercentage
{
    get { return dividendPercentage; }
    set
    {
        if ((value > 0) && (value <= 10))
            dividendPercentage = value;
    }
}



public class GameStateObject
{
    public int NumberOfPlayers = 2;
    public int[] StockToBuy = new int[Max_NumberOfCompanies + 1];
    public int MoneyToBuy = 0;
    public bool TestGame = false;
    public int Winner = 0;

    public GameStateObject()
    {

    }

    public void ResetStockExchange()
    {
        Array.Clear(StockToBuy, 0, StockToBuy.Length);
    }




}

public GameStateObject GameStateObj = new GameStateObject();

private void LoadTestGamePlayerNames()
{
    //Test Game Player Setuo
    PlayerName[0] = "Chris";
    PlayerName[1] = "Geoff";
    if (NumberOfPlayers > 2)
        PlayerName[2] = "Holly";
    if (NumberOfPlayers > 3)
        PlayerName[3] = "Muffin";
    if (NumberOfPlayers > 4)
        PlayerName[4] = "Whoever";
}

private void TestGame1()
{
    GameStateObj.TestGame = true;

    map[2, 1] = "A";
    map[3, 1] = "A";
    map[4, 1] = "A";

    map[1, 3] = "B";
    map[2, 3] = "B";
    map[3, 3] = "B";
    map[4, 3] = "B";

    map[6, 1] = "C";
    map[6, 2] = "C";
    map[5, 2] = "C";
    map[7, 1] = Map.StarSector;

    map[3, 5] = Map.BlackholeSector;

    Companies[1].OpenCompany(1, FounderShares);
    CalculateSharePrice(Companies[1]);

    Companies[2].OpenCompany(2, FounderShares);
    CalculateSharePrice(Companies[2]);

    Companies[3].OpenCompany(3, FounderShares);
    CalculateSharePrice(Companies[3]);

    StateHasChanged();

}

private void TestGame2()
{
    TestGame1();
}

//Convert a string to map values - used for loading maps for things such as testing;
private void StringToMapSection(string MapString, int StartX = 0, int Y = 0)
{
    for (int x = 0; x < MapString.Length; x++)
    {
        if ((x + StartX) < map.X_Dimension)
            map[x, Y] = MapString[x + StartX].ToString();
    }
}

//Convert an array of strings to map values - used for loading maps for things such as testing;
private void StringToMapSection(string[] MapStrings, int StartX = 0, int StartY = 0)
{
    for (int y = 0; y < MapStrings.GetUpperBound(0); y++)
    {
        if ((y + StartY) < map.X_Dimension)
            StringToMapSection(MapStrings[y], StartX, StartY);
    }
}

private void SetDefaultRounds(ChangeEventArgs e)
{
    DefaultRounds = Convert.ToBoolean(e.Value);
    if (DefaultRounds)
        UpdateRoundsBasedOnPlayerCount();

}

//private void UpdateRoundsBasedOnPlayerCount(ChangeEventArgs e)
private void UpdateRoundsBasedOnPlayerCount()
{
    //    if(e.Value.GetType() == typeof(int)) {
    //        NumberOfPlayers = Int32.Parse(e.Value.ToString());
    //    }

    switch (NumberOfPlayers)
    {
        case 2:
            NumberOfRounds = 24; break;
        case 3:
            NumberOfRounds = 18; break;
        case 4:
            NumberOfRounds = 12; break;
        case 5:
            NumberOfRounds = 10; break;
        default:
            NumberOfRounds = 12; break;
    }

}

private int SetInitialNumberOfRounds()
{
    if ((NumberOfPlayers == 5) && (NumberOfMoves == 48))
    {
        NumberOfMoves = 50;
        NumberOfRounds = 10;
    }
    else if ((NumberOfPlayers < 5) && (NumberOfMoves == 50))
    {
        NumberOfMoves = 48;
        NumberOfRounds = NumberOfMoves / NumberOfPlayers;
    }

    return NumberOfRounds;
}

private void InitializeGame()
{
    GameState = GameStates.Initiating;

    //ReDim Map
    //My = new string[X_dimension, Y_dimension];
    map = new Map(X_dimension, Y_dimension);

    //Load Test Names
    //    LoadTestGamePlayerNames();

    // Randomize who starts game first
    if (RandomizeFirstMover)
        FirstPlayer = rand.Next(0, NumberOfPlayers - 1);
    else
        FirstPlayer = 0;

    GameRound = 1;
    if (DefaultRounds)
        UpdateRoundsBasedOnPlayerCount();

    //    if (NumberOfPlayers == 5)
    //        NumberOfMoves = 50; // 48 is the usual count, but not divisible by 5

    //Mild deviation from the original - reset player numbers to put who ever goes first as player 1

    // Initialize Players
    GameStateObj.NumberOfPlayers = NumberOfPlayers;

    int nameIndex = FirstPlayer;
    for (int l = 1; l <= GameStateObj.NumberOfPlayers; l++)
    {
        // Start each Player with some $ and set their name
        if (string.IsNullOrWhiteSpace(PlayerName[nameIndex])) { PlayerName[nameIndex] = (ComputerPlayer[nameIndex] ? "Computer " : "Player ") + (nameIndex + 1).ToString(); }  // Assign default name if not entered
        Players.Add(l, new Player(PlayerName[nameIndex], PlayerStartingMoney, ComputerPlayer[nameIndex] ? Player.PlayerType.Computer1 : Player.PlayerType.Human));
        //if (ComputerPlayer[nameIndex]) { Players[nameIndex].Type = Player.PlayerType.Computer1; };
        nameIndex = (nameIndex < (GameStateObj.NumberOfPlayers - 1) ? nameIndex + 1 : 0);
    }

    // Initialize Companies
    for (int companyIndex = 1; companyIndex <= Max_Companies; companyIndex++)
    {
        Companies.Add(companyIndex, new Company(companyIndex, GameStateObj.NumberOfPlayers));
    }

    //Initialize Map with empty sectors
    for (int y = 0; y <= map.Y_Dimension; y++)
    {
        for (int x = 0; x <= map.X_Dimension; x++)
        {
            int sectortype = rand.Next(1, 100);

            if ((StarChance > 0) && (BlackholeChance > 0))
            {
                if (sectortype <= StarChance)
                    map[x, y] = Map.StarSector;
                else if (sectortype <= (StarChance + BlackholeChance))
                    map[x, y] = Map.BlackholeSector;
                else
                    map[x, y] = Map.EmptySector;
            }
            else if (StarChance > 0)
            {
                if (sectortype <= StarChance)
                    map[x, y] = Map.StarSector;
                else
                    map[x, y] = Map.EmptySector;
            }
            else
                map[x, y] = Map.EmptySector;

        }
    }

    // Initialize Stock Holdings
    StockHoldings = new int[Max_Companies, NumberOfPlayers];

    //    TestGame1();


    ExecuteTurn();

    LogGameEvent("The Game has begun!");

}


private void ExecuteTurn()
{
    GameState = GameStates.PlayerMove;

    //Generate the moves for the next player
    AvailableMoves = GenerateMoves();
    AddMovesToMap();

    if (!(Players[PlayerTurn].IsHuman))
    {
        // Computer move

        //Disable UI pieces for end user clicking

        //Have computer user make move selection
        int computerMove = 1;
        MakeMove(computerMove);
        //ExecuteMove(AvailableMoves[computerMove].X, AvailableMoves[computerMove].Y, map);
        GameState = GameStates.PlayerStockPurchasing;

        // Have computer user make stock purchases
        int computerStockToBuy = BuyComputerStock(PlayerTurn);
        if (computerStockToBuy > 0)
        {
            // MaxCanBuy
            int sharesToBuy = MaxCanBuy(computerStockToBuy);
            GameStateObj.StockToBuy[computerStockToBuy] = sharesToBuy;
            LogGameEvent(Players[PlayerTurn].Name + " purchased " + sharesToBuy.ToString() + " shares of " + Companies[computerStockToBuy].Name);
        }
    }
}

private int SelectComputerMove(Dictionary<int, Move> moves, int playerId)
{
    return 1;   //always select the first move for test purposes right now;
}

private int BuyComputerStock(int playerId)
{
    if (ExistingCompanies() == 0) { return 0; } // No Companies to buy stock in

    //Check holdings and buy more of the same company as initial logic
    int mostOwned = 0;
    int ownedShares = 0;
    int cheapestStock = 0;

    for (int i = 1; i <= Companies.Count; i++)
    {
        if (Companies[i].IsActive)
        {
            if (Companies[i].StockHolderShares[playerId] >= ownedShares)
            {
                mostOwned = i;
            }
        }
    }

    // Doesn't own any stock right now, buy cheapest
    if (mostOwned == 0)
    {

        int stockValue = 999999999;

        for (int i = 1; i <= Companies.Count; i++)
        {
            if (Companies[i].IsActive)
            {
                if(Companies[i].ShareValue < stockValue)
                {
                    cheapestStock = i;
                }
            }
        }
    }

    return (mostOwned == 0 ? mostOwned : cheapestStock);
}


public int AvailableMoneyForStockBuying()
{
    return AvailableMoneyForStockBuying(0); // pass a 0 to indicate not to exclude any company;
}

public int AvailableMoneyForStockBuying(int ExcludeCompanyId)
{
    int availableMoney = Players[PlayerTurn].Money;
    //    Console.WriteLine("StockToBuy.Length=" + GameStateObj.StockToBuy.Length + " ExcludeId = " + ExcludeCompanyId.ToString());
    //    foreach (int i in GameStateObj.StockToBuy)
    for (int i = GameStateObj.StockToBuy.GetLowerBound(0); i <= GameStateObj.StockToBuy.GetUpperBound(0); i++)
    {
        if (i != ExcludeCompanyId && Companies.ContainsKey(i) && Companies[i].IsActive)
        {
            //           Console.Write(Companies[i].Symbol + "=" + GameStateObj.StockToBuy[i]);
            availableMoney -= GameStateObj.StockToBuy[i] * Companies[i].ShareValue;
            //           Console.Write("(" + availableMoney.ToString() + ")");
        }
    }

    Console.WriteLine();
    return availableMoney;
}

public int MaxCanBuy(int CompanyKey)
{
    return Convert.ToInt32(Math.Floor(AvailableMoneyForStockBuying(CompanyKey) / (double)Companies[CompanyKey].ShareValue));
}

public void ExecuteStockTrades()
{
    for (int i = 0; i <= GameStateObj.StockToBuy.Length; i++)
    {
        if (Companies.ContainsKey(i) && Companies[i].IsActive && (GameStateObj.StockToBuy[i] > 0))
        {
            BuyStock(PlayerTurn, i, GameStateObj.StockToBuy[i]);
        }
    }
}

private int BuyStock(int playerId, int companyId, int shares)
{
    //int shares = 1;

    //Determine if the player has enough money
    if (Players[playerId].Money >= (shares * Companies[companyId].ShareValue))
    {
        //Buy shares
        Players[playerId].Money -= (shares * Companies[companyId].ShareValue);  // Take away the money
        Companies[companyId].StockHolderShares[playerId] += shares; // Add the shares
    }
    else
        shares = 0; // no shares bought

    return shares;
}

[Obsolete("Selling not exercised in this version", true)]
private int SellStock(int playerId, int companyId, int shares)
{
    // Determine if player has that many shares to sell, if trying to sell more than have, sell all
    if (Companies[companyId].StockHolderShares[playerId] < shares)
        shares = Companies[companyId].StockHolderShares[playerId];

    // Sell the stock
    Players[playerId].Money += (shares * Companies[companyId].ShareValue); // Give the money
    Companies[companyId].StockHolderShares[playerId] -= shares;

    return shares;
}

private void GetMoves()
{
    AvailableMoves = GenerateMoves();
}

private void AddMovesToMap()
{
    foreach (var m in AvailableMoves)
    {
        map[m.Value.X, m.Value.Y] = m.Key.ToString();
    }
}

private void RemoveMovesFromMap()
{
    foreach (Move m in AvailableMoves.Values)
    {
        map[m.X, m.Y] = Map.EmptySector;
    }
}

private int ExistingCompanies()
{
    return Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value).Count;
}

private Dictionary<int, Move> GenerateMoves()
{
    //        int x_move;
    //        int y_move;
    //MoveOutcome move_outcome;

    SortedDictionary<string, Move> tempMoves = new SortedDictionary<string, Move>();

    int existingCompanies = ExistingCompanies();

    List<Move> openSectors = map.OpenSectors();
    int moveIndex;

    // Find open moves
    for (int l = 1; ((l <= NumberOfMoves) && (l <= openSectors.Count)); l++)
    {
        bool moveisgood;
        // Find an open move
        do
        {
            moveIndex = rand.Next(0, openSectors.Count - 1);
            moveisgood = true; // since we pull from a list of pre-validated open sectors, start with assumption of true

            // prevent creation of too many companies
            if (existingCompanies == Max_Companies)
            {
                // check if move will create new company
                if (DetermineMoveOutcome(openSectors[moveIndex].X, openSectors[moveIndex].Y) == MoveOutcome.StartNewCompany)
                    moveisgood = false;
            }

        } while (!moveisgood);

        // Add move to the list of available moves and remove from the pool for next move selection
        Move nm = new Move(openSectors[moveIndex].X, openSectors[moveIndex].Y);
        tempMoves.Add(nm.ToString(), nm);
        openSectors.RemoveAt(moveIndex);
    }

    //Take the sorted dictionary and re-key to numeric index
    Dictionary<int, Move> moves = new Dictionary<int, Move>();
    foreach (Move mv in tempMoves.Values)
        moves.Add(moves.Count + 1, mv);

    // Ensure Map Display -- ADD CODE to mode this to a controller most likely
    GameState = GameStates.PlayerMove;
    StateHasChanged();

    //return moves;
    return moves;
}

public void MakeMove(int moveNumber)
{
    Move move = AvailableMoves[moveNumber];

    //Update Status
    GameStatus = "Player " + PlayerTurn.ToString() + " opens up sector " + move.ToString();
    // Update map with new status based on move
    RemoveMovesFromMap();
    map[move.X, move.Y] = Map.DevelopedSector;

    GameState = GameStates.PlayerStockPurchasing;

    // Calculate results of the move
    ExecuteMove(move.X, move.Y, map);

    //Advance Game
    GameState = GameStates.PlayerStockPurchasing;

}


private void EndTurn()
{
    //Buy Stocks
    if (Players[PlayerTurn].IsHuman) { ExecuteStockTrades(); } //already executed if non-human playe turn
    GameStateObj.ResetStockExchange();
    StateHasChanged();

    // Increment Turn
    bool newRound = NextPlayerTurn();

    if (GameRound > NumberOfRounds)
    {
        // The Game is over!
        GameState = GameStates.GameEnding;

        // Determine the final rankings
        foreach (var p in Players)
        {
            p.Value.FinalRank = PlayerRank(p.Key);
            if (p.Value.FinalRank == 1)
                GameStateObj.Winner = p.Key;
        }
    }
    else //start the next round
    {
        // Pay Dividends to start the round
        if (newRound) PayDividends();


        ExecuteTurn();

    }
}

private void PayDividends()
{
    foreach (var p in Players)
    {
        p.Value.Money += (int)Math.Round(PlayerStockWorth(p.Key) * (double)DividendPercentage / 100);
    }
}

    @* Returns True if new round *@
    private bool NextPlayerTurn()
    {
        PlayerTurn++;
        if (PlayerTurn > NumberOfPlayers)
        {
            PlayerTurn = 1;
            GameRound++;
            return true;
        }
        else { return false; }
    }

    private string SectorClass(string sectorValue)
    {
        switch (sectorValue)
        {
            case Map.NullSector:
                return "map-sector-null";
            case Map.EmptySector:
                return "map-sector-empty";
            case Map.DevelopedSector:
                return "map-sector-developed";
            case Map.StarSector:
                return "map-sector-star";
            case Map.BlackholeSector:
                return "map-sector-blackhole";
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
                return "map-sector-move";
        }

        if ("ABCDEFGHIJKL".Contains(sectorValue)) return "map-sector-company";

        return String.Empty;
    }

    //prints the map using text string - for debugging purposes only
    public string PrintMap()
    {
        return map.PrintMap(GameState == GameStates.PlayerMove, AvailableMoves);
    }

    public int CalculateAdjacentSectorValue(string sectorstate)
    {
        switch (sectorstate)
        {
            case Map.StarSector:
                return StarValue;
            case Map.BlackholeSector:
                return 0;
            default:
                return 0;
        }
    }

    public int CalculateSharePrice(Company company)
    {
        int value = 0;

        for (int x = 0; x <= map.X_Dimension; x++)
        {
            for (int y = 0; y <= map.Y_Dimension; y++)
            {
                if (map[x, y] == company.Symbol)    //if the company owns this sector
                {
                    value += 100; // for the sector itself
                    string[] neighbors = map.GetNeighbors(x, y);
                    foreach (string s in neighbors)
                    { value += CalculateAdjacentSectorValue(s); }
                }
            }
        }

        return value;
    }


    public int CompanySize(Company company)
    {
        return map.NumberOfSymbolsOnMap(company.Symbol);
    }

    public int PlayerStockWorth(int playerid)
    {
        int stockvalue = 0;
        foreach (Company c in Companies.Values)
        {
            stockvalue += c.StockHolderShares[playerid] * c.ShareValue;
        }
        return stockvalue;
    }

    public int PlayerNetWorth(int playerid)
    {
        return Players[playerid].Money + PlayerStockWorth(playerid);
    }

    public MoveOutcome DetermineMoveOutcome(int x, int y)
    {
        {
            // evalute nearby spaces to determine outcome of this move
            MoveOutcome moveOutcome = MoveOutcome.DevelopSector;

            //initialize adjacent locals
            string[] neighbors = map.GetNeighbors(x, y);
            List<string> adjacentCompanies = map.AdjacentCompanies(x, y);


            // Check for adjacent companies
            if (adjacentCompanies.Count == 0)
            {
                // If it's all empty sectors nearby
                if (String.Join("", neighbors) == new String('x', 4).Replace("x", Map.EmptySector))
                {
                    moveOutcome = MoveOutcome.DevelopSector;
                }

                // Check for creation of new company
                if ((String.Join("", neighbors).Contains(Map.StarSector)) || (String.Join("", neighbors).Contains(Map.DevelopedSector)))
                {
                    moveOutcome = MoveOutcome.StartNewCompany;
                }
            }
            // Check for expansion of company
            else if (adjacentCompanies.Count == 1)
            {
                moveOutcome = MoveOutcome.ExpandCompany;
            }
            // Check for Merger
            else if (adjacentCompanies.Count > 1)
            {
                moveOutcome = MoveOutcome.Merger;
            }

            //Check for black hole
            if (moveOutcome != MoveOutcome.StartNewCompany) // there will be two outcomes actually, but the new company will cause issues if max companies already exist, so prevent that
            {
                if (BlackholeChance > 0)
                {
                    if (String.Join("", neighbors).Contains(Map.BlackholeSector))
                    {
                        moveOutcome = MoveOutcome.Blackhole;
                    }
                }
            }

            return moveOutcome;
        }
    }

    public MoveOutcome ExecuteMove(int x, int y, Map theMap)
    {
        // evalute nearby spaces to determine outcome of this move
        MoveOutcome moveOutcome = MoveOutcome.DevelopSector; //default

        //initialize adjacent locals
        string[] neighbors = theMap.GetNeighbors(x, y);
        List<string> adjacentCompanies = theMap.AdjacentCompanies(x, y);

        // Develop Sector
        theMap[x, y] = Map.DevelopedSector;

        // Check for adjacent companies
        if (adjacentCompanies.Count == 0)
        {
            // If it's all empty sectors nearby
            if (String.Join("", neighbors) == new String('x', 4).Replace("x", Map.EmptySector))
            {
                // Develop Sector
                theMap[x, y] = Map.DevelopedSector;
            }

            // Check for creation of new company
            if ((String.Join("", neighbors).Contains(Map.StarSector)) || (String.Join("", neighbors).Contains(Map.DevelopedSector)))
            {
                // Make a new company
                moveOutcome = MoveOutcome.StartNewCompany;
                int newCo = AvailableCompanySlot();

                if (newCo == 0)
                { } // ?? Shouldn't end up here, no more companies available! ADD CODE to handle this?

                // Open up the new company
                Companies[newCo].OpenCompany(PlayerTurn, FounderShares);
                theMap[x, y] = Companies[newCo].Symbol;

                // Expand into any adjacent developed sectors
                if (neighbors[0] == Map.DevelopedSector)
                    theMap[x, y - 1] = Companies[newCo].Symbol;
                if (neighbors[1] == Map.DevelopedSector)
                    theMap[x - 1, y] = Companies[newCo].Symbol;
                if (neighbors[2] == Map.DevelopedSector)
                    theMap[x + 1, y] = Companies[newCo].Symbol;
                if (neighbors[3] == Map.DevelopedSector)
                    theMap[x, y + 1] = Companies[newCo].Symbol;

                LogGameEvent("NEW COMPANY!", Players[PlayerTurn].Name + " has founded a new company, " + Companies[newCo].Name + ".");
            }
        }
        // Check for expansion of company
        else if (adjacentCompanies.Count == 1)
        {
            //Expansion
            moveOutcome = MoveOutcome.ExpandCompany;

            // Expand into "move" sector
            theMap[x, y] = adjacentCompanies[0];

            // Expand into any developed adjacent sectors
            if (neighbors[0] == Map.DevelopedSector)
                theMap[x, y - 1] = adjacentCompanies[0];
            if (neighbors[1] == Map.DevelopedSector)
                theMap[x - 1, y] = adjacentCompanies[0];
            if (neighbors[2] == Map.DevelopedSector)
                theMap[x + 1, y] = adjacentCompanies[0];
            if (neighbors[3] == Map.DevelopedSector)
                theMap[x, y + 1] = adjacentCompanies[0];
        }
        // Check for Merger
        else if (adjacentCompanies.Count > 1)
        {
            //Merger!
            moveOutcome = MoveOutcome.Merger;

            //Sort companies by alpabetical
            adjacentCompanies.Sort();

            string foo = String.Empty;

            // Add the symbol and the size to a dictionary to iterate
            Dictionary<string, int>
                coS = new Dictionary<string, int>
                    ();
            foreach (string s in adjacentCompanies)
            {
                coS.Add(s, CompanySize(Companies[Company.KeyFromSymbol(s)]));
                foo += s + "=" + coS[s] + ", ";
            }

            string survivor = string.Empty;

            // Merge largest and smallest companies, until we're down to just one company
            do
            {
                int winner = 0;
                for (int i = 1; i < coS.Count; i++)
                {
                    if (coS.ElementAt(i).Value > coS.ElementAt(winner).Value)
                        winner = i;
                }

                survivor = coS.ElementAt(winner).Key;

                int loser = coS.Count - 1;
                for (int i = coS.Count - 2; i >= 0; i--)
                {
                    if (coS.ElementAt(i).Value < coS.ElementAt(loser).Value)
                        loser = i;
                }

                // merge winner and loser
                MergeCompanies(Companies[Company.KeyFromSymbol(coS.ElementAt(winner).Key)], Companies[Company.KeyFromSymbol(coS.ElementAt(loser).Key)]);

                string winnerName = Companies[Company.KeyFromSymbol(coS.ElementAt(winner).Key)].Name;
                string loserName = Companies[Company.KeyFromSymbol(coS.ElementAt(loser).Key)].Name;
                LogGameEvent("MERGER!!!!!", $"{winnerName} and {loserName} have merged! The unified company will now be known as {winnerName}.");

                //remove loser
                coS.Remove(coS.ElementAt(loser).Key);
            } while (coS.Count > 1);

            // Update the newly developed sector that created the merger
            theMap[x, y] = survivor;

            StateHasChanged();
        }

        //Check for black hole(s), that could wipe out any newly merged or expanded companies!
        if (BlackholeChance > 0)
        {
            for (int x_loop = 0; x_loop <= theMap.X_Dimension; x_loop++)
            {
                for (int y_loop = 0; y_loop <= theMap.Y_Dimension; y_loop++)
                {
                    if (theMap[x_loop, y_loop] == Map.BlackholeSector)
                    {
                        //Wipe out companies that touched the blackhole!
                        adjacentCompanies = theMap.AdjacentCompanies(x_loop, y_loop);
                        if (adjacentCompanies.Count > 0)
                        {
                            foreach (string c in adjacentCompanies)
                            {
                                theMap.ReplaceSymbolOnMap(Companies[Company.KeyFromSymbol(c)].Symbol, Map.EmptySector);
                                Companies[Company.KeyFromSymbol(c)].CloseCompany();

                                LogGameEvent("DISASTER!", Companies[Company.KeyFromSymbol(c)].Name + " sucked into black hole at Sector " + Move.ToString(x_loop, y_loop));
                            }
                        }

                        //Randomly destroy developed sectors next to blackholes
                        string[] blackholeNeighbors = theMap.GetNeighbors(x_loop, y_loop);
                        for (int n = 0; n < blackholeNeighbors.GetUpperBound(0); n++)
                        {
                            if (blackholeNeighbors[n] == Map.DevelopedSector)
                            {
                                if (rand.Next(1, 100) <= BlackholeConsumptionChance)
                                {
                                    // Destroy the sector
                                    int x_destroyed = x_loop;
                                    int y_destroyed = y_loop;
                                    if (n == 0) { y_destroyed = y_loop - 1; }
                                    if (n == 1) { x_destroyed = x_loop - 1; }
                                    if (n == 2) { x_destroyed = x_loop + 1; }
                                    if (n == 3) { y_destroyed = y_loop + 1; }


                                    // The sector just developed on this turn cannot be destroyed on the same turn
                                    if ((x != x_destroyed) && (y != y_destroyed))
                                    {
                                        theMap[x_destroyed, y_destroyed] = Map.NullSector;
                                        LogGameEvent("Sector " + Move.ToString(x_destroyed, y_destroyed) + " consumed by black hole!");
                                    }
                                }
                            }
                        }
                    }
                }
            }

        }

        // Calculate the final share prices
        foreach (Company company in Companies.Values)
        {
            company.ShareValue = CalculateSharePrice(company);
        }

        //Force redraw of maps
        StateHasChanged();  // Since our map display is a set of string, it does not seem to force a refresh for changes to Map array

        return moveOutcome;
    }

    public void MergeCompanies(Company winner, Company loser)
    {
        //Update Map
        map.ReplaceSymbolOnMap(loser.Symbol, winner.Symbol);

        // Trade in old stock
        foreach (var item in loser.StockHolderShares)
        {
            winner.StockHolderShares[item.Key] += (item.Value / MergerRatio); // Award at 2 old for 1 new
            Players[item.Key].Money += ((item.Value % MergerRatio) * loser.ShareValue); // Pay out remainer share
        }

        // Close down prior company
        loser.CloseCompany();
    }

    public int AvailableCompanySlot()
    {
        foreach (var item in Companies)
        {
            if (!item.Value.IsActive) return item.Key;
        }

        return 0;   // no available company slots
    }

    private string EventsText()
    {
        //List events in reverse chronological order
        return String.Join("<br/>", Events.ToArray().Reverse());
    }

    private void LogGameEvent(string eventText)
    {
        LogGameEvent("", eventText);
    }

    private void LogGameEvent(string eventHeader, string eventText)
    {
        if (Events.Count >= 10)
            Events.Dequeue();
        Events.Enqueue("Round " + GameRound.ToString() + "&raquo; " + eventHeader + " " + eventText);
    }



    private int PlayerRankOld(int playerId)
    {
        int rank = 1;
        int netWorth = PlayerNetWorth(playerId);
        for (int i = 1; i <= Players.Count; i++)
        {
            if (i != playerId)
            {
                int iNetWorth = PlayerNetWorth(i);
                if (iNetWorth > netWorth)       // Tie breaker one: Net Worth
                    rank++;
                else if (iNetWorth == netWorth)
                    if (PlayerStockWorth(i) > PlayerStockWorth(playerId)) // Tie breaker two: Stock value
                        rank++;
                    else if (playerId < i)  // Tie breaker three: player who had later move is considered disadvantaged, so gets ranked higher
                        rank++;
            }
        }

        return rank;
    }

    private int PlayerRank(int PlayerId)
    {
        /*
    int[] rankings = PlayerRanks();
    for (int i = 0; i <= rankings.GetUpperBound(0); i++)
    {
        if (rankings[i] == PlayerId)
            return i+1;
    }
            return 0; //oops
        */

        Dictionary<int, int> rankings = PlayerRanks();

        return rankings[PlayerId];
    }

    private Dictionary<int, int> PlayerRanks()
    {

        Dictionary<int, long> rankvalues = new Dictionary<int, long>();

        foreach (var p in Players)
        {
            // rubric for sorting
            rankvalues.Add(p.Key, PlayerNetWorth(p.Key) * (long)10000000 + PlayerStockWorth(p.Key) * 10 + p.Key);
            Console.WriteLine("Ranking value player " + p.Key + " = " + rankvalues[p.Key]);
        }

        var results = rankvalues.OrderByDescending(p => p.Value);

        Dictionary<int, int> ranking = new Dictionary<int, int>();

        foreach (KeyValuePair<int, long> pair in results)
        {
            ranking.Add(pair.Key, ranking.Count + 1);
            Console.WriteLine("Ranking value player " + pair.Key + " = " + ranking[pair.Key]);
        }

        return ranking;
    }
}

