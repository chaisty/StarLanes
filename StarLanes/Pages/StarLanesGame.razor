@page "/starlanesgame"

<div class="row">
    <h1>Star Lanes</h1>
</div>
@*
    <p>Current size: @(X_dimension)x@(Y_dimension) </p>
    <p>Current UBounds: @(Map.GetUpperBound(0))x@(Map.GetUpperBound(1)) </p>
*@

@if (GameConfig.GameState == GameConfiguration.GameStates.NotStarted)
{
<p>
    <label for="numberOfPlayers"># of Players:</label> <input id="numberOfPlayers" type="number" min="2" max="@GameConfiguration.Max_NumberOfPlayers" @bind="GameConfig.NumberOfPlayers" />
</p>
<p>
    @for (int p = 1; p <= GameConfig.NumberOfPlayers; p++)
        {

            var pa = p - 1;
    @*<span class="text-danger">@_playerNameValidationMessage(p))</span>*@
    <label for="playerName(@p)">Player @p Name:</label>  <input id="playerName(@p)" type="text" minlength="2" maxlength="20" @bind="PlayerName[pa]" />
    <label for="computerPlayer(@p)" style="font-size: small;"><input type="checkbox" id="computerPlayer(@p)" @bind="ComputerPlayer[pa]" /> Computer Player</label>
    <br />
        }
</p>

<div class="form-check-inline"><label><input type="radio" class="form-check-input" name="gameformat" value="standard" checked @onchange="(e) => GameConfig.SetMapSize(12,9)">Standard Game (12x9)</label></div>
<div class="form-check-inline"><label><input type="radio" class="form-check-input" name="gameformat" value="large" @onchange="(e) => GameConfig.SetMapSize(16,12)">Big Game (16x12)</label></div>
<div class="form-check-inline"><label><input type="radio" class="form-check-input" name="gameformat" value="jumbo" @onchange="(e) => GameConfig.SetMapSize(20,16)">Jumbo Game (20x16)</label></div>

<p>
    <button class="btn btn-primary" @onclick="InitializeGame">Start Game!</button>
</p>

<p>
    <button @onclick="(e) => ToggleAdvancedOptions()" class="btn btn-outline-secondary" data-toggle="buttons">
        @(AdvancedOptionsVisible ? "Hide" : "Show") Advanced Options
    </button>
</p>

@if (AdvancedOptionsVisible)
    {
<AdvancedOptions GameConfig=@GameConfig />
    }

}

@if ((GameConfig.GameState != GameConfiguration.GameStates.NotStarted) && (GameConfig.GameState != GameConfiguration.GameStates.GameEnding))
{

@* Game Status Header *@
<div class="row">
    <div class="col-3 header-round">
        Round @(GameStateObj.GameRound) of @(GameConfig.NumberOfRounds)
    </div>
    @* Show whose turn it is *@
    <div class="col-9 turn-instructions-panel">
        <p>
            <label style="font-weight:bold">@(TheGame.Players.ContainsKey(GameStateObj.PlayerTurn) != true ? "" : TheGame.Players[GameStateObj.PlayerTurn].Name + "'s") Turn: </label>
            <label>
                @((MarkupString)(GameConfig.GameState == GameConfiguration.GameStates.PlayerMove ? "<b>Move<b> >" : "Move > "))
                @((MarkupString)(GameConfig.GameState == GameConfiguration.GameStates.PlayerStockPurchasing ? "<b>Stock Buying<b> > " : "Stock Trading > "))
                End Turn
            </label>
        </p>
    </div>
</div>

@* Show player status *@
<div class="container row justify-content-center player-status-panel">
    <div>
        @foreach (var p in TheGame.Players)
            {

        <div class="container player-status-box @(GameStateObj.PlayerTurn == p.Key ? "player-status-box-active" : "")">
            <div class="player-status-box-name @(GameStateObj.PlayerTurn == p.Key ? "player-status-name-active" : "")">
                @(p.Value.Name + " ["+ TheGame.PlayerRank(p.Key) + "]") @((MarkupString)PlayerIcon(p.Key))
            </div>
            <div class="player-status-box-money">
                Bank: @("$" + p.Value.Money.ToString())
            </div>
            <div class="player-status-box-stocks">
                @foreach (var c in TheGame.Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value))
                        {
                @((MarkupString)(c.Value.Symbol + ":&nbsp;" + c.Value.StockHolderShares[p.Key].ToString() + "&nbsp;&nbsp; "))
                        }
            </div>
            <div class="player-status-box-networth">
                @(("Net Worth: $" + TheGame.PlayerNetWorth(p.Key)))
            </div>
        </div>
            }
    </div>
</div>

<div class="container row event-panel clearfix" style="width: 100%; height: 100px; margin: 25px 0px;">
    <div class="col-2 event-panel-title">
        Galactic Newswire
    </div>
    <div class="col-10 event-panel-readout overflow-auto">
        @((MarkupString)EventsText())
    </div>
</div>

<div class="container-fluid clearfix">
    <div class="row" style="height:400px">
        @* Container for side-by-side map and newswire*@

        @* Map Display *@
        <div class="map-panel">
            <MapDisplay GameConfig=@GameConfig GameStateObj=@GameStateObj map=@TheGame.Map OnMoveClickCallback="@MakeMove" />

        </div>

        <div class="player-actions">
            <fieldset id="playeractionelements" disabled="@(!(TheGame.Players[GameStateObj.PlayerTurn].IsHuman))">
                @* Available Move Buttons *@
                <div class="player-moves-panel">
                    @if (GameConfig.GameState == GameConfiguration.GameStates.PlayerMove)
                        {
                    <div class="player-moves-title">Available Moves:</div>
                    @foreach (var move in GameStateObj.AvailableMoves)
                            {
                    <button class="btn btn-outline-secondary move-button" hidden="@(GameConfig.GameState != GameConfiguration.GameStates.PlayerMove)" disabled="@(GameConfig.GameState != GameConfiguration.GameStates.PlayerMove)" @onclick="(e => { MakeMove(move.Key); })">@(move.Value)</button>
                            }
                    <div>
                        @* if this is testing, allow for the player to regenerate the available moves *@
                        @if (GameStateObj.TestGame)
                                {
                        <button class="btn btn-primary" @onclick="(e => { TheGame.Map.RemoveMovesFromMap(GameStateObj.AvailableMoves); GameStateObj.AvailableMoves = GenerateMoves(); TheGame.Map.AddMovesToMap(GameStateObj.AvailableMoves); })">GenerateMoves</button>
                                }
                    </div>
                        }
                </div>

                @* Stock purchasing buttons*@


                @if (GameConfig.GameState == GameConfiguration.GameStates.PlayerStockPurchasing)
                    {
                @* if there are any companies *@
                @if (TheGame.Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value).Count > 0)
                        {
                <div class="clearfix">
                    <span class="bold-small-header">Buy Stocks with $@(TheGame.Players[GameStateObj.PlayerTurn].Money) ($@(AvailableMoneyForStockBuying()) unallocated)</span>
                </div>
                <div class="clearfix">
                    @foreach (var c in TheGame.Companies)
                                {
                    @if (c.Value.IsActive)
                                    {
                    <div class="row stock-to-buy-box">
                        <div class="w-auto">
                            <label>@(c.Value.Name)&nbsp;</label>
                        </div>
                        <div class="w-auto">
                            <label for="Buy=@(c.Key)">$@(c.Value.ShareValue) x </label>
                            <input id="Buy=@(c.Key)" style="width:3em" type="number" @bind="GameStateObj.StockToBuy[c.Key]" min="0" max="@(MaxCanBuy(c.Key))" />
                            <button class="btn btn-secondary btn-xs" @onclick="() => { GameStateObj.StockToBuy[c.Key] = MaxCanBuy(c.Key); }">Max</button>
                        </div>
                    </div>
                    @*                     <button class="btn btn-secondary btn-xs" onclick="alert(" onclick="document.getElementById("Buy=@(c.Key)").value = document.getElementById("Buy=@(c.Key)").attr('max');";">Max</button> *@

                    @*
                        <label class="player-actions-buysellstock">@(c.Value.Name)</label>
                        <button class="btn btn-outline-secondary btn-xs" disabled="@(GameState != GameStates.PlayerStockPurchasing)" @onclick="(e => { BuyStock(GameStateObj.PlayerTurn, c.Key, 1); })"> + </button>
                        <span class="btn btn-outline-secondary btn-sm">@(c.Value.StockHolderShares[GameStateObj.PlayerTurn])</span>
                        <button class="btn btn-outline-secondary btn-xs" disabled="@(GameState != GameStates.PlayerStockPurchasing)" @onclick="(e => { SellStock(GameStateObj.PlayerTurn, c.Key, 1); })"> - </button>
                    *@
                                    }
                                }
                </div>

                        }
                        else @* no companies *@
                        {
                        <div>
                            No companies available for stock purchasing
                        </div>
                        }

                @* End Turn Button for Humans Players on their turns *@
                @if (TheGame.Players[GameStateObj.PlayerTurn].IsHuman)
                        {
                <div style="text-align: center; margin: 10px 0px; align-self:flex-end">
                    <button class="btn btn-primary" disabled="@(GameConfig.GameState != GameConfiguration.GameStates.PlayerStockPurchasing)" @onclick="(e => { EndTurn(); })">@(TheGame.Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value).Count > 0 ? "Buy Stocks & Complete Turn" : "Complete Turn")</button>
                </div>
                        }
                    }
            </fieldset>

            @* End Turn Button for Human to continue game after Computer Turn *@
            @if ((GameConfig.GameState == GameConfiguration.GameStates.PlayerStockPurchasing) && (TheGame.Players[GameStateObj.PlayerTurn].IsComputer))
                {
            <div style="text-align: center; margin: 10px 0px; align-self:flex-end">
                <button class="btn btn-primary" @onclick="(e => { EndTurn(); })"> Next Turn </button>
            </div>
                }
        </div>
    </div>
</div>

@* Show company status *@
<div class="company-status-panel">

    @* Leftmost box is column names *@
    <div class="company-status-key">
        <div class="company-status-box-name">
            Company:
        </div>
        <div class="company-status-box-sharevalue">
            Share Value($):
        </div>
        <div class="company-status-box-sharesoutstanding">
            Outstanding Shares:
        </div>
        <div class="player-status-box-size">
            # of Sectors:
        </div>
    </div>

    @foreach (var c in TheGame.Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value))
        {
    <CompanyStatus company=@c.Value CompanySize=@CompanySize(c.Value) />
        }

</div>
}

@if (GameConfig.GameState == GameConfiguration.GameStates.GameEnding)
{
    <GameOver GameConfig="@GameConfig" GameStateObj="@GameStateObj" TheGame="@TheGame"/>
}


@code {

    //UI only functions
    private string GenerateControlRef(int Id)
    {
        return "Move" + Id.ToString();
    }

    private const string RobotIconPath = "css/font-awesome/robot.svg";

    private string PlayerIcon(int Id)
    {
        if (TheGame.Players[Id].IsComputer)
            return "<img src=" + (char)34 + RobotIconPath + (char)34 + " width=" + (char)34 + "16" + (char)34 + " height=" + (char)34 + "16" + (char)34 + " alt=" + (char)34 + "C" + (char)34 + " />";
        else
            return "";
    }

    public bool AdvancedOptionsVisible = false;
    private void ToggleAdvancedOptions()
    {
        AdvancedOptionsVisible = !AdvancedOptionsVisible;
    }



    // Initialize Randomizer
    Random rand = new Random();

    //Initialize Player variables for initial setup
    string[] PlayerName = new string[GameConfiguration.Max_NumberOfPlayers];
    bool[] ComputerPlayer = new bool[GameConfiguration.Max_NumberOfPlayers];

    //Create Stock Holding Tracker
    public int[,] StockHoldings = new int[1, 1];    //Redim this later
    public Dictionary<string, int> Stocks = new Dictionary<string, int>();



    public Queue<GameEvent> Events = new Queue<GameEvent>();

    public GameStateObject GameStateObj = new GameStateObject();

    public GameConfiguration GameConfig = new GameConfiguration();

    public Game TheGame = new Game();

    #region Test Games
    private void LoadTestGamePlayerNames()
    {
        //Test Game Player Setuo
        PlayerName[0] = "Chris";
        PlayerName[1] = "Geoff";
        if (GameConfig.NumberOfPlayers > 2)
            PlayerName[2] = "Holly";
        if (GameConfig.NumberOfPlayers > 3)
            PlayerName[3] = "Muffin";
        if (GameConfig.NumberOfPlayers > 4)
            PlayerName[4] = "Whoever";
    }

    private void TestGame1()
    {
        GameStateObj.TestGame = true;

        TheGame.Map[2, 1] = "A";
        TheGame.Map[3, 1] = "A";
        TheGame.Map[4, 1] = "A";

        TheGame.Map[1, 3] = "B";
        TheGame.Map[2, 3] = "B";
        TheGame.Map[3, 3] = "B";
        TheGame.Map[4, 3] = "B";

        TheGame.Map[6, 1] = "C";
        TheGame.Map[6, 2] = "C";
        TheGame.Map[5, 2] = "C";
        TheGame.Map[7, 1] = GalaxyMap.StarSector;

        TheGame.Map[3, 5] = GalaxyMap.BlackholeSector;

        TheGame.Companies[1].OpenCompany(1, GameConfig.FounderShares);
        CalculateSharePrice(TheGame.Companies[1]);

        TheGame.Companies[2].OpenCompany(2, GameConfig.FounderShares);
        CalculateSharePrice(TheGame.Companies[2]);

        TheGame.Companies[3].OpenCompany(3, GameConfig.FounderShares);
        CalculateSharePrice(TheGame.Companies[3]);

        StateHasChanged();

    }

    private void TestGame2()
    {
        TestGame1();
    }
    #endregion Test Games



    private void InitializeGame()
    {
        GameConfig.GameState = GameConfiguration.GameStates.Initiating;

        //ReDim Map
        //My = new string[X_dimension, Y_dimension];
        TheGame.Map = new GalaxyMap(GameConfig.X_dimension, GameConfig.Y_dimension);

        //Load Test Names
        //    LoadTestGamePlayerNames();

        // Randomize who starts game first
        if (GameConfig.RandomizeFirstMover)
            GameConfig.FirstPlayer = rand.Next(0, GameConfig.NumberOfPlayers - 1);
        else
            GameConfig.FirstPlayer = 0;

        GameStateObj.GameRound = 1;
        if (GameConfig.DefaultRounds)
            GameConfig.UpdateRoundsBasedOnPlayerCount();

        //    if (NumberOfPlayers == 5)
        //        NumberOfMoves = 50; // 48 is the usual count, but not divisible by 5

        //Mild deviation from the original - reset player numbers to put who ever goes first as player 1

        // Initialize Players
        GameStateObj.NumberOfPlayers = GameConfig.NumberOfPlayers;

        int nameIndex = GameConfig.FirstPlayer;
        for (int l = 1; l <= GameStateObj.NumberOfPlayers; l++)
        {
            // Start each Player with some $ and set their name
            TheGame.Players.Add(l, new Player(PlayerName[nameIndex], GameConfig.PlayerStartingMoney, ComputerPlayer[nameIndex] ? Player.RandomComputerPersona() : Player.Personas.Human));
            if (string.IsNullOrWhiteSpace(TheGame.Players[l].Name))
            { TheGame.Players[l].SetDefaultName(l); }  // Assign default name if none was entered
            if (TheGame.Players[l].IsComputer)
            { TheGame.Players[l].IconPath = RobotIconPath; }
            nameIndex = (nameIndex < (GameStateObj.NumberOfPlayers - 1) ? nameIndex + 1 : 0);
        }

        // Initialize Companies
        for (int companyIndex = 1; companyIndex <= GameConfig.Max_Companies; companyIndex++)
        {
            TheGame.Companies.Add(companyIndex, new Company(companyIndex, GameStateObj.NumberOfPlayers));
        }

        //Initialize Map with empty sectors
        for (int y = 0; y <= TheGame.Map.Y_Dimension; y++)
        {
            for (int x = 0; x <= TheGame.Map.X_Dimension; x++)
            {
                int sectortype = rand.Next(1, 100);

                if ((GameConfig.StarChance > 0) && (GameConfig.BlackholeChance > 0))
                {
                    if (sectortype <= GameConfig.StarChance)
                        TheGame.Map[x, y] = GalaxyMap.StarSector;
                    else if (sectortype <= (GameConfig.StarChance + GameConfig.BlackholeChance))
                        TheGame.Map[x, y] = GalaxyMap.BlackholeSector;
                    else
                        TheGame.Map[x, y] = GalaxyMap.EmptySector;
                }
                else if (GameConfig.StarChance > 0)
                {
                    if (sectortype <= GameConfig.StarChance)
                        TheGame.Map[x, y] = GalaxyMap.StarSector;
                    else
                        TheGame.Map[x, y] = GalaxyMap.EmptySector;
                }
                else
                    TheGame.Map[x, y] = GalaxyMap.EmptySector;

            }
        }

        // Initialize Stock Holdings
        StockHoldings = new int[GameConfig.Max_Companies, GameConfig.NumberOfPlayers];

        //    TestGame1();

        LogGameEvent("The Game has begun!");

        // Start the first Turn
        ExecuteTurn();

    }


    async Task Sleep(int Duration)
    {
        await Task.Delay(Duration);
    }

    private void ExecuteTurn()
    {
        GameStateObj.LastMove = null;
        GameConfig.GameState = GameConfiguration.GameStates.PlayerMove;

        //Generate the moves for the player
        GameStateObj.AvailableMoves = GenerateMoves();
        TheGame.Map.AddMovesToMap(GameStateObj.AvailableMoves);

        if (TheGame.Players[GameStateObj.PlayerTurn].IsComputer)
        {
            ExecuteComputerTurn();
        }
    }

    async void ExecuteComputerTurn()
    {
        // Computer move

        await Sleep(1000);

        //Have computer user make move selection
        int computerMove = SelectComputerMove(GameStateObj.AvailableMoves, GameStateObj.PlayerTurn);
        MakeMove(computerMove);

        await Sleep(1000);

        //ExecuteMove(AvailableMoves[computerMove].X, AvailableMoves[computerMove].Y, TheGame.Map);
        GameConfig.GameState = GameConfiguration.GameStates.PlayerStockPurchasing;

        // Conditionally pay dividends
        if (GameConfig.DividendPayStage == GameConfiguration.DividendPayStages.BeforeStockBuying)
        {
            PayDividend(GameStateObj.PlayerTurn);
            StateHasChanged();
        }

        // Have computer user make stock purchases
        int computerStockToBuy = BuyComputerStock(GameStateObj.PlayerTurn);

        if (computerStockToBuy > 0)
        {
            // MaxCanBuy
            int sharesToBuy = MaxCanBuy(computerStockToBuy);
            GameStateObj.StockToBuy[computerStockToBuy] = sharesToBuy;
            StateHasChanged();
            // Post visible event, transaction will finalize on "Next Turn" button press by player
            if (sharesToBuy > 0)
                LogGameEvent(TheGame.Players[GameStateObj.PlayerTurn].Name + " is purchasing " + sharesToBuy.ToString() + " shares of " + TheGame.Companies[computerStockToBuy].Name);

            //GameStateObj.ResetStockExchange();
        }
    }

    private int SelectComputerMove(Dictionary<int, Move>
        moves, int playerId)
    {
        switch (TheGame.Players[playerId].Persona)
        {
            case Player.Personas.ERNIE:
                return rand.Next(1, GameStateObj.AvailableMoves.Count); ;   //random move;
            default:
                return rand.Next(1, GameStateObj.AvailableMoves.Count); ;   //random move;
        }
    }

    private int BuyComputerStock(int playerId)
    {
        if (ExistingCompanies() == 0) { return 0; } // No Companies to buy stock in

        //Check holdings and buy more of the same company as initial logic
        int mostOwned = 0;
        int ownedShares = 0;
        int cheapestStock = 0;

        for (int i = 1; i <= TheGame.Companies.Count; i++)
        {
            if (TheGame.Companies[i].IsActive)
            {
                if (TheGame.Companies[i].StockHolderShares[playerId] >= ownedShares)
                {
                    mostOwned = i;
                }
            }
        }

        // Doesn't own any stock right now, buy cheapest
        if (mostOwned == 0)
        {

            int stockValue = Int32.MaxValue;

            for (int i = 1; i <= TheGame.Companies.Count; i++)
            {
                if (TheGame.Companies[i].IsActive)
                {
                    if (TheGame.Companies[i].ShareValue < stockValue)
                    {
                        cheapestStock = i;
                        stockValue = TheGame.Companies[cheapestStock].ShareValue;
                    }
                }
            }
        }

        return (mostOwned != 0 ? mostOwned : cheapestStock);
    }


    public long AvailableMoneyForStockBuying()
    {
        return AvailableMoneyForStockBuying(0); // pass a 0 to indicate not to exclude any company;
    }

    public long AvailableMoneyForStockBuying(int ExcludeCompanyId)
    {
        long availableMoney = TheGame.Players[GameStateObj.PlayerTurn].Money;

        for (int i = GameStateObj.StockToBuy.GetLowerBound(0); i <= GameStateObj.StockToBuy.GetUpperBound(0); i++)
        {
            if (i != ExcludeCompanyId && TheGame.Companies.ContainsKey(i) && TheGame.Companies[i].IsActive)
            {
                availableMoney -= GameStateObj.StockToBuy[i] * TheGame.Companies[i].ShareValue;
            }
        }

        return availableMoney;
    }

    public int MaxCanBuy(int CompanyKey)
    {
        return Convert.ToInt32(Math.Floor(AvailableMoneyForStockBuying(CompanyKey) / (double)TheGame.Companies[CompanyKey].ShareValue));
    }

    public void ExecuteStockTrades()
    {
        for (int i = 0; i <= GameStateObj.StockToBuy.Length; i++)
        {
            if (TheGame.Companies.ContainsKey(i) && TheGame.Companies[i].IsActive && (GameStateObj.StockToBuy[i] > 0))
            {
                BuyStock(GameStateObj.PlayerTurn, i, GameStateObj.StockToBuy[i]);
            }
        }
    }

    private int BuyStock(int playerId, int companyId, int shares)
    {
        //int shares = 1;

        //Determine if the player has enough money
        if (TheGame.Players[playerId].Money >= (shares * TheGame.Companies[companyId].ShareValue))
        {
            //Buy shares
            TheGame.Players[playerId].Money -= (shares * TheGame.Companies[companyId].ShareValue);  // Take away the money
            TheGame.Companies[companyId].StockHolderShares[playerId] += shares; // Add the shares
        }
        else
            shares = 0; // no shares bought

        return shares;
    }

    [Obsolete("Selling not exercised in this version", true)]
    private int SellStock(int playerId, int companyId, int shares)
    {
        // Determine if player has that many shares to sell, if trying to sell more than have, sell all
        if (TheGame.Companies[companyId].StockHolderShares[playerId] < shares)
            shares = TheGame.Companies[companyId].StockHolderShares[playerId];

        // Sell the stock
        TheGame.Players[playerId].Money += (shares * TheGame.Companies[companyId].ShareValue); // Give the money
        TheGame.Companies[companyId].StockHolderShares[playerId] -= shares;

        return shares;
    }

    private void GetMoves()
    {
        GameStateObj.AvailableMoves = GenerateMoves();
    }

    private int ExistingCompanies()
    {
        return TheGame.Companies.Where(item => item.Value.IsActive).ToDictionary(item => item.Key, i => i.Value).Count;
    }

    private Dictionary<int, Move> GenerateMoves()
    {
        //        int x_move;
        //        int y_move;
        //MoveOutcome move_outcome;

        SortedDictionary<string, Move> tempMoves = new SortedDictionary<string, Move>();

        int existingCompanies = ExistingCompanies();

        List<Move>
            openSectors = TheGame.Map.OpenSectors();
        int moveIndex;

        // Find open moves
        for (int l = 1; ((l <= GameConfig.NumberOfMoves) && (l <= openSectors.Count)); l++)
        {
            bool moveisgood;
            // Find an open move
            do
            {
                moveIndex = rand.Next(0, openSectors.Count - 1);
                moveisgood = true; // since we pull from a list of pre-validated open sectors, start with assumption of true

                // prevent creation of too many companies
                if (existingCompanies == GameConfig.Max_Companies)
                {
                    // check if move will create new company
                    if (DetermineMoveOutcome(openSectors[moveIndex].X, openSectors[moveIndex].Y) == MoveOutcome.StartNewCompany)
                        moveisgood = false;
                }

            } while (!moveisgood);

            // Add move to the list of available moves and remove from the pool for next move selection
            Move nm = new Move(openSectors[moveIndex].X, openSectors[moveIndex].Y);
            tempMoves.Add(nm.ToString(), nm);
            openSectors.RemoveAt(moveIndex);
        }

        //Take the sorted dictionary and re-key to numeric index
        Dictionary<int, Move>
            moves = new Dictionary<int, Move>
                ();
        foreach (Move mv in tempMoves.Values)
            moves.Add(moves.Count + 1, mv);

        // Ensure Map Display -- ADD CODE to move this to a controller most likely
        GameConfig.GameState = GameConfiguration.GameStates.PlayerMove;
        StateHasChanged();

        //return moves;
        return moves;
    }

    public void MakeMove(int moveNumber)
    {
        Move move = GameStateObj.AvailableMoves[moveNumber];

        //Update Status
        //GameStatus = "Player " + GameStateObj.PlayerTurn.ToString() + " opens up sector " + move.ToString();
        LogGameEvent(TheGame.Players[GameStateObj.PlayerTurn].Name + " develops sector " + move.ToString());
        // Update Map with new status based on move
        TheGame.Map.RemoveMovesFromMap(GameStateObj.AvailableMoves);
        TheGame.Map[move.X, move.Y] = GalaxyMap.DevelopedSector;

        GameConfig.GameState = GameConfiguration.GameStates.PlayerStockPurchasing;

        // Calculate results of the move
        GameStateObj.LastMove = move;
        ExecuteMove(move.X, move.Y, TheGame.Map);

        // Conditionally pay Dividends if human player
        if (GameConfig.DividendPayStage == GameConfiguration.DividendPayStages.BeforeStockBuying)
            PayDividend(GameStateObj.PlayerTurn);

        //Advance Game
        GameConfig.GameState = GameConfiguration.GameStates.PlayerStockPurchasing;

    }


    private void EndTurn()
    {
        //Buy Stocks
        //if (Players[GameStateObj.PlayerTurn].IsHuman) { ExecuteStockTrades(); } //already executed if non-human player turn
        ExecuteStockTrades();
        GameStateObj.ResetStockExchange();
        StateHasChanged();

        // Increment Turn
        bool newRound = NextPlayerTurn();

        if (GameStateObj.GameRound > GameConfig.NumberOfRounds)
        {
            // The Game is over!
            GameConfig.GameState = GameConfiguration.GameStates.GameEnding;

            // Determine the final rankings
            foreach (var p in TheGame.Players)
            {
                p.Value.Rank = TheGame.PlayerRank(p.Key);
                if (p.Value.Rank == 1)
                    GameStateObj.Winner = p.Key;
            }
        }
        else //start the next round
        {
            // Pay Dividends to start the round
            if ((newRound) && (GameConfig.DividendPayStage == GameConfiguration.DividendPayStages.BetweenRounds))
                PayDividends();

            ExecuteTurn();

        }
    }

    private void PayDividend(int PlayerId)
    {
        TheGame.Players[PlayerId].Money += (int)Math.Round(TheGame.PlayerStockWorth(PlayerId) * (double)GameConfig.DividendPercentage / 100);
    }

    private void PayDividends()
    {
        foreach (var p in TheGame.Players)
        {
            PayDividend(p.Key);
            //p.Value.Money += (int)Math.Round(PlayerStockWorth(p.Key) * (double)GameConfig.DividendPercentage / 100);
        }
    }

    @* Returns True if new round *@
private bool NextPlayerTurn()
{
    GameStateObj.PlayerTurn++;
    if (GameStateObj.PlayerTurn > GameConfig.NumberOfPlayers)
    {
        GameStateObj.PlayerTurn = 1;
        GameStateObj.GameRound++;
        return true;
    }
    else { return false; }
}

//prints the Map using text string - for debugging purposes only
public string PrintMap()
{
    return TheGame.Map.PrintMap(GameConfig.GameState == GameConfiguration.GameStates.PlayerMove, GameStateObj.AvailableMoves);
}

public int CalculateAdjacentSectorValue(string sectorstate)
{
    switch (sectorstate)
    {
        case GalaxyMap.StarSector:
            return GameConfig.StarValue;
        case GalaxyMap.BlackholeSector:
            return (GameConfig.BlackholeDestroys ? 0 : GameConfig.BlackholeValue);
        default:
            return 0;
    }
}

public int CalculateSharePrice(Company company)
{
    int value = 0;

    for (int x = 0; x <= TheGame.Map.X_Dimension; x++)
    {
        for (int y = 0; y <= TheGame.Map.Y_Dimension; y++)
        {
            if (TheGame.Map[x, y] == company.Symbol)    //if the company owns this sector
            {
                value += 100; // for the sector itself
                string[] neighbors = TheGame.Map.GetNeighbors(x, y);
                foreach (string s in neighbors)
                { value += CalculateAdjacentSectorValue(s); }
            }
        }
    }

    return value - company.SplitOffset; // Value of sectors on Map minus prior stock split values
}


public int CompanySize(Company company)
{
    return TheGame.Map.NumberOfSymbolsOnMap(company.Symbol);
}



public MoveOutcome DetermineMoveOutcome(int x, int y)
{
    {
        // evalute nearby spaces to determine outcome of this move
        MoveOutcome moveOutcome = MoveOutcome.DevelopSector;

        //initialize adjacent locals
        string[] neighbors = TheGame.Map.GetNeighbors(x, y);
        List<string> adjacentCompanies = TheGame.Map.AdjacentCompanies(x, y);


        // Check for adjacent companies
        if (adjacentCompanies.Count == 0)
        {
            // If it's all empty sectors nearby
            if (String.Join("", neighbors) == new String('x', 4).Replace("x", GalaxyMap.EmptySector))
            {
                moveOutcome = MoveOutcome.DevelopSector;
            }

            // Check for creation of new company
            if ((String.Join("", neighbors).Contains(GalaxyMap.StarSector)) || (String.Join("", neighbors).Contains(GalaxyMap.DevelopedSector)))
            {
                moveOutcome = MoveOutcome.StartNewCompany;
            }
        }
        // Check for expansion of company
        else if (adjacentCompanies.Count == 1)
        {
            moveOutcome = MoveOutcome.ExpandCompany;
        }
        // Check for Merger
        else if (adjacentCompanies.Count > 1)
        {
            moveOutcome = MoveOutcome.Merger;
        }

        //Check for black hole
        if (moveOutcome != MoveOutcome.StartNewCompany) // there will be two outcomes actually, but the new company will cause issues if max companies already exist, so prevent that
        {
            if (GameConfig.BlackholeChance > 0)
            {
                if (String.Join("", neighbors).Contains(GalaxyMap.BlackholeSector))
                {
                    moveOutcome = MoveOutcome.Blackhole;
                }
            }
        }

        return moveOutcome;
    }
}

public MoveOutcome ExecuteMove(int x, int y, GalaxyMap theMap)
{

    //Map newMap = new Map(theMap);

    // evalute nearby spaces to determine outcome of this move
    MoveOutcome moveOutcome = MoveOutcome.DevelopSector; //default

    //initialize adjacent locals
    string[] neighbors = theMap.GetNeighbors(x, y);
    List<string> adjacentCompanies = theMap.AdjacentCompanies(x, y);

    // Develop Sector
    theMap[x, y] = GalaxyMap.DevelopedSector;

    // Check for adjacent companies
    if (adjacentCompanies.Count == 0)
    {
        // If it's all empty sectors nearby
        if (String.Join("", neighbors) == new String('x', 4).Replace("x", GalaxyMap.EmptySector))
        {
            // Develop Sector
            theMap[x, y] = GalaxyMap.DevelopedSector;
        }

        // Check for creation of new company
        if ((String.Join("", neighbors).Contains(GalaxyMap.StarSector)) || (String.Join("", neighbors).Contains(GalaxyMap.DevelopedSector)))
        {
            // Make a new company
            moveOutcome = MoveOutcome.StartNewCompany;
            int newCo = AvailableCompanySlot();

            if (newCo == 0)
            { } // ?? Shouldn't end up here, no more companies available! ADD CODE to handle this?

            // Open up the new company
            TheGame.Companies[newCo].OpenCompany(GameStateObj.PlayerTurn, GameConfig.FounderShares);
            theMap[x, y] = TheGame.Companies[newCo].Symbol;

            // Expand into any adjacent developed sectors
            if (neighbors[0] == GalaxyMap.DevelopedSector)
                theMap[x, y - 1] = TheGame.Companies[newCo].Symbol;
            if (neighbors[1] == GalaxyMap.DevelopedSector)
                theMap[x - 1, y] = TheGame.Companies[newCo].Symbol;
            if (neighbors[2] == GalaxyMap.DevelopedSector)
                theMap[x + 1, y] = TheGame.Companies[newCo].Symbol;
            if (neighbors[3] == GalaxyMap.DevelopedSector)
                theMap[x, y + 1] = TheGame.Companies[newCo].Symbol;

            LogGameEvent("NEW COMPANY!", TheGame.Players[GameStateObj.PlayerTurn].Name + " has founded a new company, " + TheGame.Companies[newCo].Name + ".");
        }
    }
    // Check for expansion of company
    else if (adjacentCompanies.Count == 1)
    {
        //Expansion
        moveOutcome = MoveOutcome.ExpandCompany;

        // Expand into "move" sector
        theMap[x, y] = adjacentCompanies[0];

        // Expand into any developed adjacent sectors
        if (neighbors[0] == GalaxyMap.DevelopedSector)
            theMap[x, y - 1] = adjacentCompanies[0];
        if (neighbors[1] == GalaxyMap.DevelopedSector)
            theMap[x - 1, y] = adjacentCompanies[0];
        if (neighbors[2] == GalaxyMap.DevelopedSector)
            theMap[x + 1, y] = adjacentCompanies[0];
        if (neighbors[3] == GalaxyMap.DevelopedSector)
            theMap[x, y + 1] = adjacentCompanies[0];
    }
    // Check for Merger
    else if (adjacentCompanies.Count > 1)
    {
        //Merger!
        moveOutcome = MoveOutcome.Merger;

        //Sort companies by alpabetical
        adjacentCompanies.Sort();

        string foo = String.Empty;

        // Add the symbol and the size to a dictionary to iterate
        Dictionary<string, int>
            coS = new Dictionary<string, int>
                ();
        foreach (string s in adjacentCompanies)
        {
            coS.Add(s, CompanySize(TheGame.Companies[Company.KeyFromSymbol(s)]));
            foo += s + "=" + coS[s] + ", ";
        }

        string survivor = string.Empty;

        // Merge largest and smallest companies, until we're down to just one company
        do
        {
            int winner = 0;
            for (int i = 1; i < coS.Count; i++)
            {
                if (coS.ElementAt(i).Value > coS.ElementAt(winner).Value)
                    winner = i;
            }

            survivor = coS.ElementAt(winner).Key;

            int loser = coS.Count - 1;
            for (int i = coS.Count - 2; i >= 0; i--)
            {
                if (coS.ElementAt(i).Value < coS.ElementAt(loser).Value)
                    loser = i;
            }

            // merge winner and loser
            MergeCompanies(TheGame.Companies[Company.KeyFromSymbol(coS.ElementAt(winner).Key)], TheGame.Companies[Company.KeyFromSymbol(coS.ElementAt(loser).Key)]);

            string winnerName = TheGame.Companies[Company.KeyFromSymbol(coS.ElementAt(winner).Key)].Name;
            string loserName = TheGame.Companies[Company.KeyFromSymbol(coS.ElementAt(loser).Key)].Name;
            LogGameEvent("MERGER!!!!!", $"{winnerName} and {loserName} have merged! The unified company will now be known as {winnerName}.");

            //remove loser
            coS.Remove(coS.ElementAt(loser).Key);
        } while (coS.Count > 1);

        // Update the newly developed sector that created the merger
        theMap[x, y] = survivor;

        //StateHasChanged();
    }

    //Check for black hole(s), that could wipe out any newly merged or expanded companies!
    if ((GameConfig.BlackholeDestroys) && (GameConfig.BlackholeChance > 0))
    {
        for (int x_loop = 0; x_loop <= theMap.X_Dimension; x_loop++)
        {
            for (int y_loop = 0; y_loop <= theMap.Y_Dimension; y_loop++)
            {
                if (theMap[x_loop, y_loop] == GalaxyMap.BlackholeSector)
                {
                    //Wipe out companies that touched the blackhole!
                    adjacentCompanies = theMap.AdjacentCompanies(x_loop, y_loop);
                    if (adjacentCompanies.Count > 0)
                    {
                        foreach (string c in adjacentCompanies)
                        {
                            theMap.ReplaceSymbolOnMap(TheGame.Companies[Company.KeyFromSymbol(c)].Symbol, GalaxyMap.EmptySector);
                            TheGame.Companies[Company.KeyFromSymbol(c)].CloseCompany();

                            LogGameEvent("DISASTER!", TheGame.Companies[Company.KeyFromSymbol(c)].Name + " sucked into black hole at Sector " + Move.ToString(x_loop, y_loop));
                        }
                    }

                    //Randomly destroy developed sectors next to blackholes
                    string[] blackholeNeighbors = theMap.GetNeighbors(x_loop, y_loop);
                    for (int n = 0; n < blackholeNeighbors.GetUpperBound(0); n++)
                    {
                        if (blackholeNeighbors[n] == GalaxyMap.DevelopedSector)
                        {
                            if (rand.Next(1, 100) <= GameConfig.BlackholeConsumptionChance)
                            {
                                // Destroy the sector
                                int x_destroyed = x_loop;
                                int y_destroyed = y_loop;
                                if (n == 0) { y_destroyed = y_loop - 1; }
                                if (n == 1) { x_destroyed = x_loop - 1; }
                                if (n == 2) { x_destroyed = x_loop + 1; }
                                if (n == 3) { y_destroyed = y_loop + 1; }


                                // The sector just developed on this turn cannot be destroyed on the same turn
                                if ((x != x_destroyed) && (y != y_destroyed))
                                {
                                    theMap[x_destroyed, y_destroyed] = GalaxyMap.ConsumedSector;
                                    LogGameEvent("Sector " + Move.ToString(x_destroyed, y_destroyed) + " consumed by black hole!");
                                }
                            }
                        }
                    }
                }
            }
        }

    }

    // Calculate the final share prices
    foreach (Company company in TheGame.Companies.Values)
    {
        if (company.IsActive)
        {
            company.ShareValue = CalculateSharePrice(company);

            // Check for bankruptcy
            if (company.ShareValue <= 0)    // for games that use blackholes as negative values on stock price
            {
                company.CloseCompany();
                LogGameEvent("BANKRUPCTY!", company.Name + " has gone bankrupt and is out of business.");
            }

            // Check for stock split
            if (GameConfig.StockSplits)
            {
                while (company.ShareValue >= GameConfig.StockSplitPrice)
                {
                    company.SplitStock(GameConfig.StockSplitPrice);
                    LogGameEvent("Stock Split!", company.Name + " has split 2-for-1.");
                }
            }
        }
    }


    //Force redraw of maps
    StateHasChanged();

    return moveOutcome;
}

public void MergeCompanies(Company winner, Company loser)
{
    //Update Map
    TheGame.Map.ReplaceSymbolOnMap(loser.Symbol, winner.Symbol);

    // Trade in old stock
    foreach (var item in loser.StockHolderShares)
    {
        winner.StockHolderShares[item.Key] += (item.Value / GameConfig.MergerRatio); // Award at 2 old for 1 new
        TheGame.Players[item.Key].Money += ((item.Value % GameConfig.MergerRatio) * loser.ShareValue); // Pay out remainer share
    }

    // Close down prior company
    loser.CloseCompany();
}

public int AvailableCompanySlot()
{
    foreach (var item in TheGame.Companies)
    {
        if (!item.Value.IsActive) return item.Key;
    }

    return 0;   // no available company slots
}

private string EventsText()
{
    //List events in reverse chronological order
    string eventString = String.Empty;
    for (int i = Events.Count - 1; i >= 0; i--)
    {
        bool currentTurn = ((GameStateObj.GameRound - 1) * GameConfig.NumberOfPlayers + GameStateObj.PlayerTurn == Events.ElementAt(i).Turn);
        eventString += (currentTurn ? "<b>" : "") + Events.ElementAt(i).Message + (currentTurn ? "</b>" : "") + "<br />";
    }
    return eventString;
    //return String.Join("<br />", Events.ToArray().Reverse());
}

private void LogGameEvent(string eventText)
{
    LogGameEvent("", eventText);
}

private void LogGameEvent(string eventHeader, string eventText)
{
    if (Events.Count >= 10)
        Events.Dequeue();
    Events.Enqueue(new GameEvent((GameStateObj.GameRound - 1) * GameConfig.NumberOfPlayers + GameStateObj.PlayerTurn, "Round " + GameStateObj.GameRound.ToString() + "&raquo; " + eventHeader + " " + eventText));
}



}

